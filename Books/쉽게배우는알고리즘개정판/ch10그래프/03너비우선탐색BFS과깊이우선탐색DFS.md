# 03 너비 우선 탐색(BFS)과 깊이 우선 탐색(DFS)
- 그래프의 모든 정점을 방문하는 방법은 `너비 우선 탐색`과 `깊이 우선 탐색`이 대표적으로 있다.

- 너비 우선 탐색(BFS)
1. 루트를 시작으로 탐색을 한다면 너비 우선 탐색은 먼저 루트의 `자식을 차례로 방문`한다. <br />
2. 루트 자식의 자식, 즉 루트에서 두 개의 간선을 거쳐서 도달할 수 있는 정점을 방문한다. <br />
3. 루트에서 세 개의 간선을 거쳐서 도달하는 정점들 순으로 `루트에서 거리 순으로 방문`한다.<br />

- 깊이 우선 탐색(DFS)
1. 루트의 자식 정점을 하나 방문한 다음 `아래로 내려갈 수 있는 곳까지 내려간다`.<br />
2. 더 이상 내려갈 수 없으면 `위로 되돌아오다가 내려갈 곳이 있으면 즉각 내려간다`.<br />

- 그림 10-13에서 `BFS`는 옆으로(너비로) 쭉 훑어나가고, `DFS`는 아래로(깊이로) 갈 수 있는 데까지 갔다가 막히면 되돌아와서 다시 내려간다.

<img width="459" alt="그림 10-13" src="https://user-images.githubusercontent.com/40673012/97235135-90f89980-1825-11eb-8a56-239ca8370029.png">

## 일반적인 그래프 G=(V, E)에 대한 BFS와 DFS
### BFS
- 그림 10-14는 무향 그래프에서 대해 BFS를 수행하는 예다. <br /><br />

1. 그림(a): 시작 정점으로 정해진 정점을 방문한다(1로 표시)<br/>
2. 그림(b): (a)에서 방문한 정점에 인접한 정점을 모두 방문한다(각각 2, 3, 4로 표시)<br/>
3. 그림(c): 정점 2, 3, 4에 인접한 정점을 모두 방문한다. (5, 6, 7)<br/>
4. 그림(d): 정점 5,6,7에 인접한 정점을 모두 방문한다. (8)<br/>
5. 마지막으로 정점 8에 인접한 정점 중 방문하지 않은 정점이 없어 더 이상 갈 곳이 없으므로 끝낸다.<br/>

- 검은색의 굵은 간선들은 각 정점을 처음으로 방문할 때 사용한 간선들이다. <br />
`그래프 G에서 이 간선들만 남기면` 트리가 되는데 이를 `너비 우선 트리`라 한다(그림 e).

<img width="539" alt="그림 10-14" src="https://user-images.githubusercontent.com/40673012/97235138-92c25d00-1825-11eb-897c-c52bae11a1a5.png">

### 알고리즘 10-1 BFS 알고리즘
```
BFS(G, s)
{
    for each v ∈ V-(s)
        visited[v] <- NO;
    visited[s] <- YES;  //s:시작 정점
    enqueue(Q,s);       //Q:큐
    while(Q!=Ø){
        u<-dequeue(Q);
        for each v ∈ L(u)   //L(u): 정점 u의 인접 정점 집합 
            if(visited[v]=NO)then{
                visited[v]<-YES;
                enqueue(Q,v);
            }
    }
}

```
1. 시작 정점을 제외한 모든 정점을 "방문하지 않았다(visited[v] <- NO)"로 표시한다. <br />
2. 큐의 맨 앞에 있는 정점을 빼내고 이에 인접한 정점 중 방문하지 않은 정점을 모두 "방문하였다(visited[v]<-YES)"로 표시하고 큐에 넣는다. <br />
3. BFS가 수행되는 동안 enqueue()와 dequeue()를 각각 정확히 V번씩 호출한다.<br />
    - 즉, 각 정점이 큐에 한 번씩 들어갔다 나온다.
    - BFS의 수행 시간은 Θ(V+E)이다.

### DFS
- 그림 10-14는 무향 그래프에서 대해 BFS를 수행하는 예다. <br /><br />

1. 그림(a): 시작 정점으로 정해진 정점을 방문한다(1로 표시) <br />
2. 그림(b): 정점 1에 인접한 정점 중 하나를 방문한다(2로 표시) <br />
3. 그림(c):  정점 2에 인접하면서 방문하지 않은 정점은 총 세 개다. 이 중 하나를 방문한다(3으로 표시) <br />
4. 그림(d):  정점 3에 인접하면서 방문하지 않은 정점은 두 개다. 이 중 하나를 방문한다(4로 표시) <b r/>
5. 그림(e):  정점 4에 인접한 정점 중 방문하지 않은 정점은 하나뿐이다. 이를 방문한다(5로 표시). <br />
5에 인접한 정점 중 방문하지 않은 정점은 없으므로, 왔던 길로 되돌아간다.<br />
정점 4, 3, 2로 되돌아가는 과정에서 정점 4, 3에 인접한 정점 중 방문하지 않은 정점은 없다. <br />
6. 그림(f):  정점 2로 되돌아오면 이에 인접한 정점 중 방문하지 않은 정점이 하나 있다. 이를 방문한다(6으로 표시)<br/>
7. 그림(g): 정점 6에 인접한 정점 중 방문하지 않은 정점은 두 개다. 이 중 하나를 방문한다(7로 표시). <br/>
8. 그림(f):  정점 7에 인접한 정점 중 방문하지 않은 정점은 없다. 정점 6으로 돌아간다. <br/>
정점 6에 인접한 정점 중 방문하지 않는 정점이 하나 있다. 이를 방문한다(8로 표시). <br />
정점 8에 인접한 정점 중 방문하지 않은 정점은 없으므로, 정점 6으로 돌아간다. <br />
정점 6에서도 인접한 정점 중 방문하지 않은 정점은 없으므로, 정점 2로 돌아간다.  <br />
정점 2에서도 인접한 정점 중 방문하지 않은 정점은 없으므로, 정점 1로 돌아간다.  <br />
시작 정점 1에서도 인접한 정점 중 방문하지 않은 정점은 없으므로, 끝낸다.  <br />

- 그림에서 검은색의 굵은 간선들은 각 정점을 처음으로 방문할 때 사용된 간선들이다.
(i)는 각 정점을 처음으로 방문할 때 사용한 간선들로 만들어진 트리로 이 트리를 깊이 우선 트리라 한다.

<img width="517" alt="그림 10-15" src="https://user-images.githubusercontent.com/40673012/97235144-95bd4d80-1825-11eb-80a0-a8158e32965d.png">

### 알고리즘 10-2 DFS 알고리즘
```
DFS(v){
    visited[v] <- YES;
    for each x ∈ L(v)   //L(v): 정점 v의 인접 정점 집합
        if (visited[x]=NO) then DFS(x);
}
```

- 정점 v에 대해 `DFS(v)가 호출`되면 먼저 점점 v를 "방문하였다(visited[v] <- YES)"로 표시하고 <br />
이와 인접한 정점 중 방문하지 않은 정점에 대해 각각 DFS를 호출한다. 
- 정점 v에 인접한 정점 중 `방문하지 않은 정점 x, y, z`가 있더라도 x에 대해 DFS를 호출하면 <br />
DFS는 일단 깊이 들어갈 수 있는 데까지 들어가기 때문에 정점 y나 정점 z가 다른 정점과 인접하면 방문될 수도 있다.
    - 즉, DFS(x)를 끝내도 오면 방문하지 않은 상태였던 정점 y, z가 방문된 상태가 되어 있을 수 있다.
- 궁극적으로 모든 정점에 대해 DFS(s)가 한 번씩 호출되어, DFS의 수행 시간은 Θ(V+E)이다. <br />

- BFS, DFS는 모두 연결 그래프를 가정한 것이다. <br />
만일 분리된 두 개 이상의 부분 그래프가 있다면 BFS나 DFS를 부분 그래프의 수만큼 수행해야 모든 정점을 방문할 수 있다.


