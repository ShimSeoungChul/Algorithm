# 02 그래프의 표현

- 컴퓨터에서 그래프의 표현법에는 크게 `행렬`을 이용하는 방법과 `리스트`를 이용하는 방법이 있다.

## 1 인접 행렬을 이용한 방법

### 방향성, 가중치가 없는 관계 그래프의 표현
- 그래프 G=(V,E)에서 정점의 총수가 n이라 하자. 우선 n x n 행렬을 준비한다. <br />
정점 i와 점점 j간에 `간선이 있으면` 행렬의 (i, j) 원소와 (j, i) 값을 1로 할당한다. <br />
간선으로 연결된 두 정점은 `인접`(Adjacent)하다고 한다. <br />
이런 식으로 모든 `간선`에 대해서 행렬의 해당 원소에 `1`을 할당하고, `나머지 원소`를 `0`을 할당한다. 

<img width="356" alt="그림 10-5" src="https://user-images.githubusercontent.com/40673012/97234637-94d7ec00-1824-11eb-8682-36aa77d98032.png">

###  방향성이 없고, 가중치가 있는 관계 그래프의 표현

- 그림 10-5와 다르게 행렬의 각 원소에 1 대신 가중치를 저장한다.

<img width="363" alt="그림 10-6" src="https://user-images.githubusercontent.com/40673012/97234773-e3858600-1824-11eb-87ab-613d3bde7995.png">

### 방향성이 있고, 가중치가 없는 관계 그래프의 표현

- 유향 그래프는 간선이 방향을 가지므로 인접 행렬은 그림 10-5, 10-6과 달리 대칭이 아니다.

<img width="367" alt="그림 10-7" src="https://user-images.githubusercontent.com/40673012/97234775-e54f4980-1824-11eb-8c95-08c1e3b90535.png">

### 방향성, 가중치가 있는 관계 그래프의 표현


<img width="369" alt="그림 10-8" src="https://user-images.githubusercontent.com/40673012/97234784-e7190d00-1824-11eb-905e-7071dd7d868a.png">

### 결론
- 행렬 표현법의 장점: 1. 이해하기 쉽고 2. 간선의 존재 여부를 즉각 알 수 있다.
    - 정점 i와 정점 j의 인접 여부는 행렬의 (i, j)원소나 (j, i) 원소의 값만 보면 알 수 있기 때문
- 단점: n x n 행렬이 필요하므로 `n²에 비례하는 공간`이 필요하고, 
행렬 준비 과정에서 행렬의 `모든 원소를 채우는 데만 n²에 비례하는 시간`이 든다. <br />
따라서 O(n²) 미만의 시간이 소요되는 알고리즘이 필요한 경우, <br />
행렬 준비 과정에만 Θ(n²)의 시간을 소모해버려 적절하지 않다.<br />

- `간선의 밀도가 아주 높은 그래프`에서는 인접 행렬 표현이 적합하다.
    - 예) 전체 (i, j) 쌍에서 `둘 중 하나 꼴로 간선이 있는 경우` 행렬 사용이 효율적
    - 하지만 100만 개의 정점을 가진 그래프에서 간선이 200만 개밖에 없는데, 행렬 표현을 쓰면 시간과 공간이 많이 낭비된다.<br />
    행렬의 총 원소 수는 1조 개인데 이 중 고작 200만(또는 400만)개만 1로 채워지고 나머지는 0이기 때문이다.


## 2 인접 리스트를 이용한 방법
- 각 정점들을 리스트로 표현하는 방법
- 구현: 각 정점마다 리스트를 하나씩 만든다. 여기에 각 정점에 인접한 연결 리스트로 매단다. <br />
- 인접 리스트 표현은 행렬 표현과 달리 `존재하지 않는 간선`은 표현상에 없다. <br />

### 방향성, 가중치가 없는 관계 그래프의 표현(단순 관계 그래프)
- `간선 하나`에 대해 `노드가 2개`씩 만들어진다. 
- 각 노드는 `<정점 번호, 다음 정점의 포인터>`로 구성된다. 
-  `무향 그래프`를 위한 인접 리스트 표현에서 `필요한 총 노드 수`는 존재하는 `총 간선 수의 2배`다.
    - 정점 i, j가 인접하면 정점 i의 연결 리스트에 정점 j가, 정점 j의 연결 리스트에 정점 i가 매달려 <br />
    한 간선당 노드가 2개씩 만들어지므로.
- `유향 그래프`의 경우 `간선 하나`당 `노드가 하나`씩 존재한다. 

<img width="482" alt="그림 10-9" src="https://user-images.githubusercontent.com/40673012/97234792-e97b6700-1824-11eb-9fe7-8d5236ea3fe6.png">

###  방향성이 없고, 가중치가 있는 관계 그래프의 표현

- 각 노드는 <정점 번호, 가중치, 다음 정점의 포인터>로 구성된다. 

<img width="532" alt="그림 10-10" src="https://user-images.githubusercontent.com/40673012/97234975-42e39600-1825-11eb-8db6-c1e0eb13fca0.png">

### 결론
- 인접 리스트의 장점: `공간`이 `간선의 총수에 비례`하는 양만큼 필요하므로 대채로 행렬 표현에 비해 공간 낭비가 없다.
    - 모든 가능한 정점 쌍에 비해 간선 수가 적을 때 특히 유용
- 단점: 1. `거의 모든 정점 쌍에 간선이 존재하는 경우` 오히려 리스트를 만드는 데 필요한 오버헤드만 더 든다. <br />
2. 정점 i, j 간에 `간선이 존재하는지 알아볼 때` 리스트에서 차례대로 훑어야 하므로 인접 행렬 표현보다 시간이 많이 걸린다.
    - 간선이 많다면 최악의 경우 n에 비례하는 시간이 들 수 있어, 이를 이용하는 알고리즘의 성능에 치명적일 수 있다.    <br />
    그래서 인접 리스트 표현법은 간선 밀도가 아주 높은 경우 적합하지 않다.(이때는 인접 행렬 표현법 사용)


## 3 인접 배열과 인접 해시 테이블
- 문제점: 연결이 촘촘하지 않은 그래프라도 크가가 크면 인접 리스트를 쓰기 어렵다. <br />
두 정점 간의 간선 존재 여부를 체크하는 일이 잦으면 수행 시간에 큰 시간을 준다.<br />

- 해결: 각 정점에 연결된 정점들을 연결 리스트에 저장하는 대신 배열로 저장하면, <br />
1. 연결 리스트의 포인터를 관리하는 번거로움에서 해방되고, <br />
2. 두 정점의 인접 여부를 체크하는 시간도 대폭 줄일 수 있다. <br />

- 그림 10-11은 그림 10-9의 연결 리스트 표현을 배열로 대체한 예이다. <br />
정점 j,  i가 인접한지 체크하려면, i의 인접 배열에서 j의 존재를 확인하면 된다. <br />


### 성능
- 배열을 정렬된 형태로 만들면 `이진 탐색`을 쓸 수 있어 임의의 정점에 인접한 정점 수가 k라면 <br />
`log₂k+1`번 이내의 비교로 j의 존재를 확인할 수 있다.
- 인접 배열의 크기가 100이라면 인접 리스트를 쓰면 최악의 경우 100개의 원소와 비교하지만, <br />
인접 배열을 쓰면 7개 이하면 충분하다. <br />
- 이 정도면 `공간 사용은 인접 리스트`에 준하고, `검색 시간은 대폭 줄여` 실용적으로 손색이 없다.

### 인접 배열 헤더 사용
- 각 정점의 `인접 배열 헤더`에 인접 정점이 `몇 개`인지 표시해두면 `탐색`을 쉽게 할 수 있다. <br />

<img width="380" alt="그림 10-11" src="https://user-images.githubusercontent.com/40673012/97234985-470fb380-1825-11eb-91f5-d62ee6d2a37f.png">

### 배열의 할당
- 그림 10-11 처럼 각 정점의 인접 배열을 위해 각 공간을 따로 할당받을 수도 있고, <br />
`공간의 깔끔함`을 위해 `하나의 배열`을 할당받은 다음 같이 사용할 수도 있다. <br />

- 각 인접 배열 크기를 더해 필요한 `전체 배열 크기`를 다 계산한 다음 `하나의 배열`을 할당받는다. <br />
각 `헤더``에는 자신의 인접 배열이 끝나는 자리르 표시해둔다. <br />

- 그림 10-12는 그림 10-11을 하나의 해열로 처리한 예다. <br />
이 배열을 A[10]라 할때, 정점 1은 A[1 ... 4], 정점 2는 A[5...6], ... , 정점 6은 A[14...16]에 저장되어 있다.

<img width="379" alt="그림 10-12" src="https://user-images.githubusercontent.com/40673012/97234994-4d059480-1825-11eb-96ff-f01030d3a8f2.png">


### 해시 테이블 사용

-  `그래프가 매우 크면` 이진 탐색을 한다고 해도 자주 하는 것은 만만치 않다. 
    - 예) 인접 배열의 평균 크기가 100만이라면 이진 탐색을 해도 최대 22번의 비교가 필요 
- 각 인접 배열을 하나씩 `해시 테이블`로 대체하는 방법도 있다. <br />

- `장점`: 1.각 인접 배열의 크기의 두 배 정도의 공간을 할당하여 적재율을 0.5로 만들면 평균 2번 이내로 비교 가능하다. <br />
2. 원소 집합이 고정된 해시 테이블이므로 어느 정도 `충돌`이 일어나는지 `미리 알 수` 있다. <br />
3. `적재율`을 마음대로 미리 정할 수 있다. 인접 배열의 두 배 공간도 인접 리스트에 준하는 크기다. <br />

- `단점`: 어떤 정점에서 인접한 정점들을 `차례로` 보면서 하는 작업에 적합하지 못하다. <br />
임의의 두 정점이 인접한지만 `체크`하는 경우에는 아주 매력적이다. 

- 해시 테이블을 위한 공간을 할당받을 때도 따로 할당 받거나, <br />
하나의 배열에 인접 배열 크기의 두 배 정도를 할당받아 그림10-12와 같은 방법으로 나누어쓰면 된다.



