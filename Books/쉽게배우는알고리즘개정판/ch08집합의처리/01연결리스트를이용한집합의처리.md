# 01 연결 리스트를 이용한 집합의 처리

## 1 작업의 개요
- 연결 리스트를 이용한 표현에서는 `각 원소당 하나의 노드`를 만들고 이들을 `연결 리스트로 연결`한다.
- 각 노드에는 원소를 저장하는 `필드`와 다음 원소, 대표 원소를 가리키는 `두 개의 포인터`가 있다.
    - `다음 원소`를 가리키는 포인터를 이용해 집합의 모든 원소가 `연결 리스트`로 연결된다. 
    - 각 집합의 `대표 원소`는 연결 리스트의 맨 앞에 있는 원소다.
- 각 집합에는 마지막 원소를 가리키는 `tail`이라는 변수를 두는데,  <br />
이 변수는 두 집합을 합칠 때 `시간을 절약`할 수 있게 해준다.

### 상호 배타적 집합의 관리를 위해 필요한 세 가지 연산
- Make-Set(x): 원소 x로만 구성된 집합을 만든다.
- Find-Set(x): 원소 x를 가진 집합을 알아낸다.
- Union(x, y): 원소 x를 가진 집합과 원소 y를 가진 집합을 하나로 합친다. <br />

- Make-Set(x)는 `원소 하나로 구성된 집한`을 만들고, 노드를 하나 만들어 해당 원소를 저장한다. <br />
`대표 노드`로는 자신을 가리키도록 하고, 다음 원소는 없으므로 `포인터`는 NIL로 한다.

<img width="467" alt="그림8-1연결리스트를이용하는표현에서하나의원소로구성된집합" src="https://user-images.githubusercontent.com/40673012/95642375-20dadb80-0ae3-11eb-8fa0-7a97cd32c2b6.png">

- Find-Set(x)는 원소 x가 가리키는 대표 노드를 리턴한다. 
<br />

- Union(x, y)는 <br />
1. 우선 Find-Set(x)와 Find-Set(y)를 이용하여 x, y가 속한 집합의 `대표 노드를 각각 알아내`고, <br />
2. 두 집합 중 하나를 `다른 집합 뒤에 붙인다`. <br />
3. 이렇게 뒤에 붙는 집합을 `부집합`, 앞쪽 집합을 `주집합`이라 하면, <br />
우선 `주집합의 tail 노드`의 다음 원소 포인터를 `부집합의 대표 노드`를 가리키도록 바꾸면 <br />
두 리스트가 하나로 합쳐진다. <br />
4. 마지막으로 `부집합 모든 노드의 대표 원소 포인터`는 `주집합의 대표 노드`를 가리키도록 바꾼다.

<img width="291" alt="그림8-2연결리스트를이용하는집합의표현에서두집합을합치는작업" src="https://user-images.githubusercontent.com/40673012/95642385-259f8f80-0ae3-11eb-948e-eb954ddf81d9.png">

- 위 그림을 보면 `각 집합의 모든 원소`가 `대표 원소를 가리키는 포인터를 하나씩` 갖는 걸 볼 수 있다.
- 이 대표 원소 포인터로 각 원소는 자신이 소속된 집합을 나타낸다.

## 수행 시간
### Make-Set
- 하나의 원소로 된 집합을 초기화하는 것이므로 `상수 시간`이 든다. 

### Find-Set
- 해당 원소의 노드에 있는 대표 원소 포인터만 리턴하면 되므로 상수 시간이 든다.

### Union
- O(m + nlogn) <br />

- 시간이 가장 많으 드는 작업: 대표 원소를 가리키는 포인터를 바꾸어주는 일. <br />
때문에 `큰 집합을 그대로` 두고 `작은 집합을 붙이는 것`이 대표 원소 포인터를 `갱신하는 비용`이 덜 든다.
    - 이런 방식으로 두 집합을 합치는 것을 `무게를 고려한 Union(Weighted Union)`라 한다.
    
- 무게를 고려한 Union을 처리하면 아래와 같은 성질이 만족된다.
    
#### 정의 8-1
- 연결 리스트를 이용해 표현되는 배타적 집합에서 무게를 고려한 Union을 사용할 때  <br />
m번의 Make-Set, Union, Find-Set 중 n번이 Make-Set이라면 이들의 총 수행 시간은 O(m+nlogn)이다.

