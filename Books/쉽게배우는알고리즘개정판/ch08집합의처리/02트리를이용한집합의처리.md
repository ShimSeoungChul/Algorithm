# 02 트리를 이용한 집합의 처리
## 1 기본 원리
- 연결 리스트를 이용하는 방법보다 효율적이다.
- `일반적인 트리와는 조금 다른 방식`의 표현을 쓴다. <br />
트리를 나타낼 때는 보통 부모 노드가 자식 노드를 가리키도록 하지만 여기서는 `자식 노드가 부모 모드를 가리킨다`. <br />

- 아래 그림 처럼 임의의 노드에서 부모를 가리키는 포인터를 따라가다 보면 
자식이 속한 트리의 루트 노드를 만나게 되며, 이 `루트 노드`가 `집합의 대표 노드`다.

<img width="325" alt="그림8-3트리를이용한집합표현의예" src="https://user-images.githubusercontent.com/40673012/95642407-4d8ef300-0ae3-11eb-8664-3826185df3ca.png">

- 트리를 이용한 표현에서 `두 집합을 합치는 작업`은 <br />
두 집합 집합 중 한 집합의 루트가 `다른 집합의 루트`를 가리키도록 `포인터 하나만 변경`하면 된다.

<img width="479" alt="그림8-4트리를이용한표현에서두집합을합치는예" src="https://user-images.githubusercontent.com/40673012/95642408-4ff14d00-0ae3-11eb-8352-163a5390a852.png">

- `하나의 원소로 구성된 집합`은 노드를 하나 생성하고, `부모가 자신`이 되도록 포인터를 만들면 된다.

<img width="270" alt="그림8-5트리를이용하는집합표현에서하나의원소로구성된집합" src="https://user-images.githubusercontent.com/40673012/95642409-5384d400-0ae3-11eb-9d35-cd7759585306.png">

## 알고리즘 8-1 트리를 이용한 집합의 처리에서 Make-Set, Union, Find-Set
```
//노드 x를 유일한 원소로 하는 집합을 만든다.
Make-Set(x)
{
    p[x]<-x;
}

//노드 x가 속한 집합과 노드 y가 속한 집합을 합친다.
Union(x,y)
{
    p[Find-Set(y)] <- Find-Set(x);
}

//노드 x가 속한 집합을 알아낸다. 노드 x가속한 트리의 루트 노드를 리턴한다.
Find-Set(x)
{
    if(x=p[x])
    then return x;
    else return Find-Set(p[x);
}

```


## 2 연산의 효율을 높이는 방법
### 2.1 랭크를 이용한 Union
- 각 노드는 `자신을 루트로 하는 서브 트리의 높이`를 `랭크(Rank)`라는 이름으로 저장한다. <br />
단 하나의 노드로 된 트리의 높이는 0이라고 정의한다. <br />
`루트 노드의 랭크`가 `해당 집합의 랭크`가 된다. 

- 랭크를 이용한 Union에서는 두 집합을 합칠 때 랭크가 낮은 집합을 랭크가 높은 집합에 붙인다.

<img width="242" alt="그림8-6집합을표현한트리에서각노드의랭크가표시된예" src="https://user-images.githubusercontent.com/40673012/95642449-8c24ad80-0ae3-11eb-8fe5-9fc26a660a35.png">

- 아래 그림을 보면 랭크 1인 집합을 랭크 2인 집합에 붙였고 두 집합의 합집합 랭크는 여전히 2이다. <br />
이런 방식으로 합칠 때 `합집합의 랭크가 커지는 경우`는 `두 집합의 랭크가 동일한 경우`밖에 없다.

<img width="470" alt="그림8-7랭크를이용한Union의예" src="https://user-images.githubusercontent.com/40673012/95642451-95ae1580-0ae3-11eb-8a87-1eebc58223ae.png">

#### 알고리즘 8-2 랭크를 이용한 Union과 Make-Set
```
//노드 x를 유일한 원소로 하는 집합을 만든다.
Make-Set(x){
    p[x]<-x;
    rank[x]<-0;
}

//노드 x가 속한 집합과 노드 y가 속한 집합을 합친다.
Union(x,y){
    x'<- Find-Set(x);
    y'<- Find-Set(y);
    if(rank[x']>rank[y'])
        then p[y']<-x;
        else{
            p[x']<-y';
            if(rank[x']=rank[y']) then rank[y']<-rank[y']+1;
        }
}
```

### 2.2 경로 압축
- 경로 압축은 Find-Set을 행하는 과정에 경로의 길이를 줄이는 아이디어를 넣은 것이다.
- 알고리즘 8-1의 Find-Set과 같이 행하되 Find-Set(x)를 수행 중 만나는 모든 노드가 직접 루트를 가리키도록 포인터를 바꾼다.  <br />
이러면 트리의 랭크(높이)를 줄일 가능성이 높아 진다. <br />

- 아래 그림은 노드 g에서 루트에 이르는 경로상에 있는 모든 노드가 직접 루트 노드를 가리키도록 바꾸었다.

<img width="468" alt="그림8-6트리를이용한표현에서경로압축을사용하는find-set(g)직후의모양" src="https://user-images.githubusercontent.com/40673012/95642452-99419c80-0ae3-11eb-82cd-e9ca25b67e4b.png">

- 아래 알고리즘은 경로 압축을 이용한 Find-Set 알고리즘으로, `함수의 리턴 값`을 이용하여 포인터를 갱신하고 있다. 알고리즘 6-3, 6-6에서 유사한 예를 볼 수 있다.

#### 알고리즘 8-3 경로 압축을 이용한 Find-Set
```
//노드 x가 포함된 트리의 루트를 리턴한다.
Find-Set(x){
    if(p[x] != x) then p[x] <- Find-Set(p[x]);
    return [x];
}
```

### 2.3 효율성
- 트리를 이용한 집합의 처리에서 연산의 수행 시간 

#### 정의 8-2
- 랭크를 이용한 Union을 사용하면 랭크가 k인 노드를 대표로 하는 집합의 원소 수는 최소한 2ᴷ개다. 

#### 정의 8-3
- 랭크를 이용한 Union을 사용하면, 원소 수가 n인 집합을 표현하는 트리에서 임의의 노드의 랭크는
O(log n)이다.

#### 정의 8-4
- 트리를 이용해 표현되는 배타적 집합에서 랭크를 이용한 Union을 사용할 때, <br />
m번의 Make-Set, Union, Find-Set 중 n번이 Make-Set이라면, 이들의 총 수행 시간은 O(mlogn)이다.

#### 정의 8-5
- 트리를 이용해 표현되는 배타적 집합에서 랭크를 이용한 Union과 경로 압축을 이용한 Find-Set을 동시에 사용하면, <br />
m번의 Make-Set, Union, Find-Set 중 n번이 Make-set일 때 이들의 수행 시간은 O(mlog*n)이다.
- log*n = min{k|loglog...log(k번적용) n<=1} <br />
즉 n에 log를 계속 적용할 때 k번을 적용하면 최초로 1 이하로 된다는 뜻이다.













