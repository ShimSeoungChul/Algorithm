
# 1 최소 신장 트리
- 최소 신장 트리를 위한 프림 알고리즘, 크루스칼 알고리즘은 그리디 알고리즘으로 최적해가 보장되는 예들이다.

```
//G(V,E): 주어진 그래프
//r: 시작 정점
Prim(G, r){
    S<-⌀; //S: 정점 집합  
 1) for each u ∈ V
        d[u]<-∞;
    d[r]<-0;
   2) while(S!=V){  // n회 순회
        3) u<-extractMin(V-S,d):
           S<-S U {u};
        4) for each v ∈ L(u)    // L(u): 정렬 u의 인접 정점 집합
            5) if(v ∈ V-S and w(u,v) <d[v]) then{
                6)d[v]<-w(u,v);
                7)tree[v]<-u;
                }
    }
}

extractMin(Q,d[]){
    집합 Q에서 d값이 가장 작은 정점 u를 리턴한다.
}
```

- 집합 S에 지금까지 처리가 끝난 정점들의 집합이 들어 있고, 아직 처리가 끝나지 않은 정점(V-S) 중에서 집합 S로 연결하는 간선 중 가장 짧은 간선을 가진 정점(u)을 집합 S에 더한다. 어떤 시점이든지 그 시점에서 집합 S에 가장 싼 비용으로 연결되는 정점을 택한다. 그리디하며, 최적해를 놓치지 않는다.

# 2 회의실 배정 문제
- 문제: <br />
회사에 회의실이 1개 있다. 여러 부서에서 회의실을 사용하므로 미리 신청을 받아 스케줄링한다. <br />
회의실을 사용하고자 하는 부서는 원하는 시작 시간과 종료 시간을 명시해서 신청서를 제출한다. <br />
이렇게 받은 n개의 회의 신청에 대해 회의실 사용 스케줄을 정하려 한다. <br />
목표는 겹치는 회의가 없게 하면서 `가장 많은 수의 회의`를 소화할 수 있도록 하는 것이다. <br />
이때 앞 회의의 종료 시간과 바로 다음 회의의 시작 시간이 같아도 된다.

## 알고리즘 11-7 회의실 배정을 위한 그리디 알고리즘
```
// S = {(s𝒊,t𝒊) | 𝒊 = 1, 2, ..., n}, n:신청 회의 수
// s𝒊: 시작 시간, t𝒊: 종료 시간  
Greedy_Schedule(S,n){
    t𝒊에 대한 오름차순으로 정렬하고, 이 순서대로 S={(s𝒊,t𝒊) | 𝒊 = 1, 2, ..., n}의 번호를 다시 매긴다;  //즉, 종료 시간이 가장 이른 회사가 (s1,t1)이 된다.
    T<-{1}
    last<-1;
    for(i<-, i<=n, i++)
        if(t(last) <= s𝒊){
            T <- T U {i};
            last <- i;
        }
    return T;    
}
```
- 예: 8개의 회의가 신청된 상황이고,  종료 시간이 빠른 순서로 각 시작, 종료 시간을 정렬한 결과가 다음과 같다고 하자.
`(3,5), (1,6), (6,7), (5,9), (8,13), (7,14), (12,18), (16,20)` <br />
알고리즘은 이 순서로 회의들을 포함시킬지 체크한다.<br />
먼저 1번 회의 (3, 5)는 무조건 들어간다. 1번 회의가 끝나는 시간은 5다.<br />
(1, 6)은 앞에 배정된 회의와 겹치는 시간이 있으므로 제외된다.<br />
(6, 7)은 겹치지 않아 포함된다. 이제 배정된 회의가 끝나는 시간은 7이다.<br />
(5, 9)는 제외된다. (8, 13)은 포함된다. (7, 14), (12, 18)은 제외된다. (16, 20)은 포함된다. <br />
즉, 차례가 왔을 떄 자신의 시작 시간이 이미 배정된 회의 중 맨 마지막에 끝나는 것 보다 뒤면 포함시키는 일을 반복한다.<br />
배정 결과는 다음과 같다. `(3,5), (6,7), (8,12),(16,20)`

- 이것은 직관과 어긋나 보인다. 가장 많은 회의를 소화하려면 소요 시간이 짧은 회의부터 고려하려하거나 시작 시간이 가장 빠른 경향이 있다.  이런 방식들은 최적해를 보장하지 않는다.

## 정의 11-1 Greedy_Schedule()은 항상 최적해를 구한다.
- 신청받은 회의들을 종료 시간이 빠른 순서로 1, 2, ..., n까지 번호를 매기자. 우선 회의 1을 포함하는 최적해가 존재한다는 사실을 보이자.
- 회의 1을 포함하지 않는 최적해 T가 있다 하자. T에서 가장 먼저 끝나는 회의를 i라 하자. <br />
그러면 회의 i를 빼고 회의 1을 넣어도 합법적인 스케줄이 된다. 즉, TU{1}-{i};로 바꾸어도 역시 최적해가 된다.<br />
일단 회의 1을 포함시켜 놓고 나머지 중에서 같은 방식으로 최적해를 찾으면 된다.

# 3 그 밖의 예
- 그래프에서 최단 경로를 구하는 다익스트라 알고리즘
- 문서에서 각 원소들의 출현 빈도가 주어질 때 해당 문서를 효율적으로 압축하는 코드를 만드는 허프만 코딩 알고리즘

<img width="461" alt="p373-3" src="https://user-images.githubusercontent.com/40673012/101099541-2eef3900-3608-11eb-88ca-25f8803505b8.png">


<img width="484" alt="그림11-3" src="https://user-images.githubusercontent.com/40673012/101099545-3282c000-3608-11eb-9421-3164f2e1e5d3.png">

<img width="453" alt="그림 11-2" src="https://user-images.githubusercontent.com/40673012/101099550-344c8380-3608-11eb-82bc-c813b220e42e.png">




