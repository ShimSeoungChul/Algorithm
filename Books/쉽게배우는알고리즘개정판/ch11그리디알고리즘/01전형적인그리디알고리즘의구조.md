# 01 전형적인 그리디 알고리즘의 구조
- 그리디 알고리즘이란? 눈앞의 이익만 우선 추구하는 알고리즘을 총칭한다. 대부분의 경우 뛰어난 결과를 도출하지 못ㅎ하지만 드물게 최적해를 보장하는 경우도 있다. ex) 매트로이드 구조, 그러나 이것도 상당한 공간을 할애해야한다.

## 알고리즘 11-1 전형적인 그리디 알고리즘의 구조
```
do{
    //가장 좋아 보이는 선택을 한다.
} until (해 구성 완료)
```

- 그리디 알고리즘은 하나의 온전한 해가 만들어진 때까지 눈앞에 가장 좋아 보이는 선택을 반복한다. <br />

## 알고리즘 11-2 그리디 알고리즘의 예: 프림 알고리즘
- 정점이 n개인 최소 신장 트리는 사이클을 이루지 않는 총 n-1개의 간선으로 이루어진다.
이 문제를 푸는 그리디 알고리즘은 간선이 하나도 없는 집합에서 시작해서 간선을 하나씩 더해가면서 n-1개의 간선이 될 때까지 집합을 키워나간다. 
- 이 과정의 각 단계에서 어떤 간선을 택할지 결정하는 로직이 필요하고, 이 로직이 이 눈앞의 이익만 추구하면 그리디 알고리즘 계열에 속한다. 
- 최소 신장 트리 문제에서는 간선을 하나 더할 때마다 해당 간선이 기존에 선택된 간선들과 사이클을 이루지는 않는지 확인해야 한다.
```
//G=(V,E): 그래프, r: 시작 정점
Prime(G, r){
    S<-∅; T<-∅; //S:정점 집합, T:간선 집합
    정점 r을 집합 S에 더한다;
    while(S!=V){
        S에서 V-S를 연결하는 간선들 중 최소 길이의 간선(x,y)를 찾는다; //x ∈ S, y ∈ V-S
        T에 간선(x,y)를 더한다.
        정점 y를 집합 S에 더한다.
    }
}
```
- 간선의 집합 T는 공집합으로 시작해 알고리즘이 끝나면 n-1개의 간선을 갖고, 그것이 최적해가 된다.


## 알고리즘 11-3 그리디 알고리즘
```
//C:원소들의 총 집합
Greedy(C){
    s<-∅;
    while(C!=∅ and S는 아직 온전한 해가 아님){
        1)x<-C에서 원소 하나 선택;
          집합 C에서 x를 제거한다; // C <-C - {x};  
        2) if(S에 x를 더해도 됨) then S<-S U {x};
    }
    if(S가 온전한 해임) then return S;
                     else return "해 없음!";
}
```

- 1)에서 원소를 선택하는 기준이 눈앞의 이익을 우선하면 그리디 알고리즘 계열에 속한다. <br />
프림 알고리즘은 집합 S에 속하는 정점과 집합 S에 속하지 않는 정점을 연결하는 간선들 중 가장 짧은 것을 우선 택한다.  최소 신장 트리는 간선의 합을 최소로 하는 신장 트리를 찾는 것이다.
떄문에 부분적으로 만들어진 신장 트리에 연결할 수 있는 간선 중 가장 짧은 것을 우선 택하자는 것이다.
- 이런 근시안적 선택이 최적해를 보장하는 경우는 드물다.  `최소 신장 트리 문제`는 이런 방식으로 최적해가 보장되는 드문 예 중 하나다.
- 2)는 원소를 하나 더하기 전에 해당 원소를 더하여 온전한 해가 될 가능성이 없어지지 않았은지 체크하는 부분이다.

