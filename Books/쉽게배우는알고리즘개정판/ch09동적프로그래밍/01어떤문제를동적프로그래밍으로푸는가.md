# 01 어떤 문제를 동적 프로그래밍으로 푸는가
- 동적 프로그래밍은 큰 문제의 해답에 작은 문제의 해답이 포함되어 있어, <br />
이를 `재귀호출 알고리즘`으로 구현하면 `지나친 중복`이 발생하는 경우 <br />
이 `재귀적 중복을 해결`하는 방법을 뜻한다.

## 최적 부분 구조 Optimal substructure
- 큰 문제의 해답에 그보다 작은 문제의 해답이 포함되어 있으면 최적 부분 구조를 가졌다고 한다.
ex) 피보나치 수 f(n) = f(n-1) + f(n-2)

- 최적 부분 구조는 `동적 프로그래밍`을 적용할 문제가 가져야할 필수 조건이다.

## 알고리즘 9-1 피보나치 수 (재귀호출)
fib(n)
{
    if(n = 1 or n  = 2)
        then return 1;
        else return (fib(n-1)+fib(n-2));
}

- 최적 부분 구조는 문제의 해답을 구하기 위해 더 작은 문제의 해답을 이용하므로 <br />
`재귀적 알고리즘`으로 구현하는 것이 자연스럽고 간명하지만, 때때로 엄청난 `비효율`을 초래할 수 있다. <br />
n의 피보나치 수를 구하는 앞의 재귀적 알고리즘은 `지수 함수에 비례`하는 시간이 든다.

- 아래 표를 보면 문제의 크기가 커지면 중복이 더 심해짐을 알 수 있다. 중복 호출 횟수 자체가 <br/>
다시 피보나치 수열을 이루며 `증가 속도는 Ω(2^n/2)`, 즉 적어도 `2^n/2` 이상의 비율로 증가해 지수 함수적이다.

<img width="461" alt="그림9-1,표9-1" src="https://user-images.githubusercontent.com/40673012/95649231-7335ef80-0b17-11eb-8142-8a13b8a353f4.png">

- 비효율 발생 원인: 한 번만 저장해 놓았다가 나중에 그냥 사용만 하면 될 것을 매번 호출하기 때문이다.
- `부분 결과를 저장`하면서 해를 구해나가는 것이 동적 프로그래밍의 핵심이다.

### 동적 프로그래밍이란?
- 다음 두 성질이 있는 문제를 적절한 저장 방법으로 중복 호출의 비효율을 제거하는 것
    - `최적 부분 구조`를 이룬다.
    - `재귀적`으로 구현했을 때 `중복 호출`로 심각한 `비효율`이 발생한다.
    
- 제귀를 효율적으로 다루는 방법

## 알고리즘 9-2 피보나치 수(동적 프로그래밍 1)
```
fibonacci(n){
    f[1]<-f[2]<-1;
    for i<-3 to n
        f[i]<-f[i-1]+f[i-2];
    return f[n];
}
```

- 위 알고리즘은 배열 f[]에 작은 것부터 저장해가면서 계산하는 방식으로,<br />
for 루프가 한 번 돌 때마다 앞에서 구해 저장해놓은 피보나치 수 두 개를 배열에서 가져다 더하기만 하면 된다.

- for 루프를 순환하는 것이 수행 시간을 좌우하므로 `선형 시간 알고리즘`이다. 

## 알고리즘 9-3 피보나치 수(동적 프로그래밍 2)
```
// 배열 f[]의 모든 원소를 0으로 초기화되어 있다. 
// f[i] 값이 0이면 fib(i)가 아직 한 번도 수행되지 않았음을 의미한다. 
fib(n){
    1)if(f[n]!=0) then return f[n];
    else{
            if(n=1 or n=2)
                then f[n]<-1;
                else f[n]<-fib(n-1)+fib(n-2);
            return f[n];
    }
}
```
- fib(i)가 처음으로 수행되면 f[i]에 fib(i)의 결과를 저장한다. <br />
그리고 호출된 fib(i)가이전에 호출된 적이 있으면 재귀적 호출을 하지 않고 저장된 f[i]를 리턴한다. <br />
1) f[i] 값이 아직 0으로 남아 있으면 호출 x. <br />

- `재귀를 사용`하되 `한 번 호출된 것은 메모(Memoization)`해둠으로써 중복 호출을 피하였다. 이것도 동적 프로그래밍이다.

- 알고리즘 9-3은 `탑다운 방식`의 동적 프로그래밍으로 `하향식 방법`이다. <br />
상대적으로 알고리즘 9-2 같이 `아래에서 위로 저장`해가면서 해를 구해가는 것은 `바텁업방식`의 동적 프로그래밍으로 `상향식 방법`이다. <br />
두 가지 방식 모두 작은 문제들의 해를 테이블에 저정한다는 점은 동일하다.

