# 02 행렬 경로 문제

- 양수로 이루어진 N x N 행렬이 주어진다.<br />
행렬의 `왼쪽 위`에서 시작해 `한 칸`씩 이동해 `오른쪽 아래`까지 도달한다.<br />
이 과정에서 `방문한 칸에 있는 수들을 더한 값`이 이 `경로의 합`이다.<br />
이동 규칙은 다음과 같다.<br /><br />

1. 오른쪽이나 아래쪽으로만 이동할 수 있다. <br />
2. 왼쪽, 위쪽, 대각선 이동은 허용하지 않는다.

<br />

<img width="284" alt="그림9-2허용되지않는이동과허용되는이동의예" src="https://user-images.githubusercontent.com/40673012/95649229-729d5900-0b17-11eb-9941-fc7b0def5957.png">

## 최적 부분 구조
- 1. 행렬의 왼쪽 위 `원소 (1,1)`에서 `원소 (t, j)`까지 도달하는 경로들의 `최고점`을 구한다고 가정하면, 
`원소 (i, j)`에 도달하기 `직전에 방문`할 수 있는 `원소는 (i-1, j)와 (i, j-1)` 단 두 개다.
- 2. 원소 (i, j)는 방문하므로 원소 (i, j)의 값은 반드시 더하며, <br />
(i-1, j) 또는 (i, j-1)를 거쳐  (i, j)에 도달하는 경우 중 점수가 높은 쪽을 택한다. <br />

- 즉, (i-1, j) 까지 도달하는 최고 점수와 (i, j-1)까지 도달하는 최고 점수 중 큰 것에 원소 (i, j)를 더하면 <br />
원소 (i, j)까지 도달하는 최고 점수가 된다. 
- 다르게 말하면, `문제 (i, j)의 최적해`는 `문제(i-1, j)의 최적해`와 `문제 (i, j-1)의 최적해`로 설명된다. <br />
즉, 자신의 부분 문제에 대한 최적해를 자신의 최적해를 구성하는 데 사용한다. `최적 부분 구조`를 갖는다.

## 최적 부분 구조를 재귀적 관계로 나타내자
- Cij를 `원소 (1,1)에서 원소 (i,j)에 이르는 최고 점수`, mij는 `행렬의 원소 (i,j)의 값`이라 정의하자. <br />
최종적으로 구할 값은 Cnn이다. 그러면 Cij는 다음과 같이 재귀적 관계로 나타낼 수 있다. 
- if i = 0 or j = 0 then Cij = 0 <br />
otherwise Cij = mij + max{C i, j-1, C i-1, j }<br />

- Cij는 두 가지 경우로 나뉜다.
    - 1. `i=0 또는 j=0`이면 이 행렬에는 존재하지 않는 자리에 이르는 최고 점수다. <br />
    경계치 역할을 하는 것으로 항상 다른 선택보다 열등하도록 `값 0`을 갖는다.
    이렇게 함으로써 따로 추가해야할 (1, 1), (1, j), (i, 1) 세 가지 경우를 다음 (i, j)에 포함시킬 수 있다.
    - 2. `이 경우가 아니면` 원소 (i, j)의 바로 `왼쪽 원소`에 이르는 최고 점수와  원소 (i, j)의 바로 `위 쪽 원소`에 이르는 최고 점수 중 `큰 것에 원소 (i, j)의 값을 더한것`이 원소 (i, j)에 이르는 최고 점수다.


## 알고리즘 9-4 행렬 경로 문제 (재귀호출)
```
//(i, j)에 이르는 최고 점수
matrixPath(i, j){
    if(i=0 or j) then return 0;
    else return (mij + (max(matrixPath(i-1,j),matrixPath(i,j-1))));
}
```

- 그림 9-3 은 matrix(4,4)를 수행할 때 재귀 호출 관계를 트리로 나타낸 것이다. <br />
경계조건에 해당하는 mat(0, j), mat(i, 0)들은 그리지 않았다. <br />
상당한 중복 호출이 관찰된다.문제가 커지면 중복 호출이 지수 함수적으로 일어난다.

<img width="430" alt="그림9-3matrixPath(4,4)를수행하는과정의재귀적호출관계를나타내는트리" src="https://user-images.githubusercontent.com/40673012/95649227-7204c280-0b17-11eb-8238-27d79f72073c.png">

|수행되는 matrixPath()|matrixPath(2,1)의 중복 호출 횟수|
|matrixPath(2,2)|1|
|matrixPath(3,3)|3|
|matrixPath(4,4)|10|
|matrixPath(5,5)|35|
|matrixPath(6,6)|126|
|matrixPath(7,7)|462|
|matrixPath(8,8)|1,716|
|matrixPath(9,9)|6,435|

## 알고리즘 9-5 행렬 경로 문제 (동적 프로그래밍)
```
//(n, n)에 이르는 최고 점수
matrixPath(n)
{
     for i<-0 to n
        c[i,0]<-0;
     for j<-1 to n 
        c[0, j]<-0;
    1)for i<-1 to n
         for j<- 1 to n
         2) c[i,j] <- mij + max(c[i-1,j], c[i,j-1]);
    return c[n,n];
}
```

- n x n 행렬에 대해서 이 문제에 존재하는 부분 문제의 총수는 고작 n²개다. <br />
이 n²을 알고리즘 9-5와 같이 작은 것부터 재귀적 관계를 이용해 구해나간다. <br />

- 알고리즘 9-5의 `수행 시간`은 1)의 for 루프가 지배한다. <br />
`2)`는 배열의 두 원소 중 큰 것을 고르는 작업과 덧셈이므로 `상수 시간`이 든다. <br />
그러므로 알고리즘의 `총 수행 시간`은 `Θ(n²)`이다. 행렬의 원소 수(n²)에 대해서는 선형 시간이다.


