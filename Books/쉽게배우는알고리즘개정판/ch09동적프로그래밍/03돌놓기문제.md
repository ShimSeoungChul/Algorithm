# 03 돌 놓기 문제

- 문제 설명: 3 x n 테이블의 각 칸에 숫자가 쓰여 있다. 테이블의 각 칸 중 일부에 `제한조건을 만족`하는 방법으로 `돌을 놓고`, 돌이 놓인 곳에 있는 `수의 합을 최대`로 하는 문제다.<br />
돌을 놓는 제한조건은 다음과 같다. <br />
- 가로나 세로로 인접한 두 칸에 동시에 돌이 놓일 수 없다.
- 각 열에는 적어도 하나 이상의 돌을 놓는다. <br />

<img width="399" alt="그림9-4돌놓기문제의예와돌을놓는예" src="https://user-images.githubusercontent.com/40673012/95649221-6fa26880-0b17-11eb-9f39-88a5bd00544e.png">

- 임의의 열에 돌을 놓을 수 있는 `방법`은 총 `네 가지`다. 
- 임의의 열에 한 `패턴`으로 돌이 놓이면, 인접한 열에 이 패턴과 `양립`할 수 없는 패턴으로 돌을 놓을 수는 없다.

<img width="485" alt="그림9-5임의의옆에놓을수있는네가지패턴예" src="https://user-images.githubuserconten

- 양립할 수 있는 패턴: `패턴1`의 이웃에는 패턴 2와 3만, <br />
`패턴 2`의 이웃에는 패턴 1, 3, 4만, <br />
`패턴 3`의 이웃에는 패턴 1, 2, <br />
`패턴 4`의 이웃에는 패턴 2만 올 수 있다(양립할 수 있다.)

t.com/40673012/95649222-703aff00-0b17-11eb-8576-87d972764309.png">
<img width="454" alt="그림9-6서로양립할수있는패턴들"

- 돌을 놓는 `모든 경우의 수`를 따져본 다음 가장 높은 점수를 구할 수 있으나 `지수 함수적 시간`이 걸린다.

## 최적 부분 구조
- n열 중 1열부터 i열까지 돌을 놓는 경우에 `1열부터 i열까지 합의 최고치`를 생각해보자. <br />
i열에는 `네 가지 패턴` 중 하나로 돌이 놓일 것이므로 다음 네가지를 구해보자.
    - i열이 패턴 1로 놓여 있을 경우의 최고점
    - i열이 패턴 2로 놓여 있을 경우의 최고점
    - i열이 패턴 3로 놓여 있을 경우의 최고점
    - i열이 패턴 4로 놓여 있을 경우의 최고점 <br />

- `i열이 패턴 4`로 놓여 있으면 `i-1열은 패턴 2`로 놓여있다. 따라서 i열이 패턴 4로 놓이면 <br />
최고점은 i-1열이 패턴 2로 놓일 경우의 최고점과 i열에서 패턴 4로 돌이 놓인 곳에 수를 합한 점수다.
`i열이 패턴 1`로 놓여 있으면  최고점은 `i-1열이 패턴 2`로 놓인 경우의 최고점과 <br />
`i-1열이 패턴3`으로 놓인 경우의 최고점 중 큰 것과 i열에서 패턴 1로 돌이 놓은 곳의 수를 합한 점수다. <br />

- 이처럼 `i열까지 최적해`는 `i-1 열까지 최적해를 포함`한다. <br />
즉, 자신보다 크기가 하나 작은 문제의 최적해를 자신의 최적해를 구성하는 데 사용하며, `최적 부분 구조`를 갖는다. <br />

- 최적 부분 구조 정리: 변수 Cᵢ𝘱, Wᵢ𝘱를 다음과 같이 정의한다.
    - Cᵢ𝘱: i열이 패턴 p로 놓일 때의 최고 점수
    - Wᵢ𝘱: i열이 패턴 p로 놓일 때 i열에 돌이 놓인 곳의 점수 합
- 재귀적 관계:
    - if i = 1 then Cᵢ𝘱 = W₁𝘱
    - if i > 1 then  max{Cᵢ₋₁,𝘲} + Wᵢ𝘱 //p와 양립하는 패턴 q 
- 최종적으로 C𝑛,₁ ~  C𝑛,₄ 중 가장 큰 것이 `답`이다.
    
## 알고리즘 9-6 돌 놓기 문제(재귀호출)
```
// i 열이 패턴 p로 놓일 떄 최고 점수
// w[i, p]: i열이 패턴 p로 놓일 떄 i열에 돌이 놓은 곳의 점수 합. p ∈ {1,2,3,4}
pebble(i, p)
{
    if(i=1)
        then return w[1,p];
        else {
            max <- -∞;
            for q <- 1 to 4
            if (패턴 q가 패턴 p와 양립) then {
                tmp <- pebble(i-1, q);
                if (tmp > max) then max <- tmp;
            }
            return (max + w[i,p]);
        }
}
```

- 최종적으로 pebble(n,1)~pebble(n,4)의 결과 중 최댓값이 답이다.
- 그림 9-7은 이 알고리즘으로 pebble(5,1)을 수행할 때 재귀호출 관계를 트리로 나타낸다. <br />
상당한 중복 호출이 관찰된다.

<img width="454" alt="그림9-7,표9-3" src="https://user-images.githubusercontent.com/40673012/95649226-716c2c00-0b17-11eb-8bf2-cb3239f6517a.png">

- 표 9-3은 문제의 크기가 커질때 함수 pebble()의 총 호출 횟수의 증가를 보여준다. <br />
지금까지 돌 놓기 문제의 `최적 부분 구조`와 `재귀적 구현에서 중복 호출`을 확인했으며, <br />
이 문제가 `동적 프로그래밍의 좋은 대상`임을 알 수 있다. <br />

- 문제에 존재하는 부분 문제를 모두 나열하면 C1,1~C1,4, C2,1~C2,4, ... , Cn1 ~ Cn,4가 되어 `총 4n개`다. <br />
함수 pebble()을 한 번 호출하는 것은 부분 문제 한 개와 대응된다. <br />
이 4n개를 `작은 것부터 저장`해가면서 구하면 중복을 피할 수 있다.

|문제의 크기(n)|부분 문제의 총수|부분 문제의 총수|함수 pebble()의 총 호출 횟수|
|---|---|----|
|1|4|4|
|2|8|12|
|3|12|30|
|4|16|68|
|5|20|152|
|6|24|332|
|7|28|726|


## 알고리즘 9-7 돌 놓기 문제(동적 프로그래밍)
```
//n열까지 돌을 놓을 때 최고 점수
pebble(n){
    for p <- 1 to 4
        peb[1,p] <- w[11,p];
    1) for i <- 2 to n
        for p <- 1 to 4
            peb[i,p] <- max{peb[i-1,q]} + w[i, p]; //p와 양립하는 패턴q
    return max[peb[n,p]}; // p = 1, 2, 3, 4
}
```

- `부분 문제들의 답`은 n x 4 배열 peb[][]에 저장한다.  <br />
이 알고리즘의 `수행 시간`은 1)의 for 루프가 지배한다. <br />

- 바깥쪽의 for 루프는 n-1번 반복되고, 각 반복마다 안쪽의 for 루프는 단지 4번만 반복되므로 <br />
중첩된 for 루프는 총 4(n-1)번 반복된다.
- 반복할 때마다 peb[i,p]를 구하기 위해 최대 3개의 양립되는 패턴을 살펴볼 뿐이므로, <br />
1)의 for 루프는 4(n-1)번 반복할 때마다 `상수 시간`이 소요된다. <br />
그러므로 `수행 시간은 Θ(n)`이다.

