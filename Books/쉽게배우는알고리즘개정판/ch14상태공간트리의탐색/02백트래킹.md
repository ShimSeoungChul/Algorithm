# 02 백트래킹
- 백트래킹은 DFS와 같은 방식으로 탐색하는 모든 방법을 뜻함
    - 탐색을 하다가 더 갈 수 없으면 왔던 길을 되돌아가 다른 길을 찾는다고 해서 이름이 붙음

## 특징
1. 주로 재귀적으로 구현 <br />
2. 기본적으로 모두 DFS 범주에 속함 (조금씩 변형은 일어남) <br />
3. 백트래킹 알고리즘이 상태 공간 트리를 명시적으로 만드는 것은 아니지만, <br />
알고리즘의 진행 과정은 `상태 공간 트리 루트`에서 시작해서 `DFS 방식`으로 탐색을 해나가는 것과 대응

## 1 미로 찾기 문제
- 그림 (a)는 주어진 미로이며, S는 시작 지점, T는 목표 지점 
- 그림 (b)는 이 미로를 탐색하다가 선택을 해야 하는 지점, 즉 분기점들을 정점으로 나타낸 것
- 그림 (c)는 미로 찾기 문제의 탐색 과정을 상태 공간 트리로 표현한 것 

### (c)의 상태 공간 트리 설명
- S에서 시작해 정점 1로 이동한다. 정점 2 또는 3 중 하나를 선택할 수 있다.
- 임의로 정점 2를 선택한다. 2에 도착하여 막다른 골목임임을 안다.
- 정점 2로 오는데 거쳤던 중간 지점 1로 돌아온다. 
- 정점 3으로 이동한다. 정점 4 또는 5 중 하나를 선택할 수 있다. 정점 5를 선택한다.
- 정점 5로 이동하다. 정점 6과 7 중 하나를 선택할 수 있다. 정점 6을 선택한다.
- 정점 6으로 이동한다. 막다른 골목임을 알게 된다.
- 정점 6으로 오기 위해 거친 중간 지점 5로 돌아온다. 
- 정점 7로 이동한다. 정점 8, 10 T 중 하나를 선택할 수 있다. 정점 T를 선택한다.
- 정점 T에 도착하여 목표 지점임을 안다. 탐색을 끝낸다. <br />

- 백트래킹은 이렇게 가보고 되돌아오고를 반복하는 것
- 운이 좋으면 시행착오를 덜 거치고 목적지에 도착할 것이고, 최악의 경우에 모든 경우를 다 거친 다음 목적지에 도착함
- 그림 (c)에서 ●, ◼︎으로 나타낸 부분은 운 좋게 가보지 않고 탐색을 끝낸 노드들이다.

<img width="389" alt="그림 14-4 미로 찾기 문제와 이를 상태 공간 트리로 나타낸 예" src="https://user-images.githubusercontent.com/40673012/98877276-6e23e180-24c3-11eb-8b8a-961b04df948d.png">


### 알고리즘 14-1 미로 찾기 문제를 위한 백트래킹 알고리즘
- 알고리즘이 끝난 후 S에서 T에 이르는 경로를 알려면, <br />
T에서 시작해 prev[]를 통해 따라가면 S에 이른다. 이의 역방향이 해답 경로다. 이 알고리즘은 사실상 `DFS`와 같다.
```
maze(v){
    visited[v] = YES;
    if(v=T) then {return "성공";} //끝내기
    for each x ∈ L(v)
        if (visited[x] = NO) then {
            prev[x]<-v;
            maze(x);
        }
}
```

## 2 색칠 문제
- 그림 14-5는 그래프의 색칠 문제다. <br />
그림 (b)는 서로 인접한 구역을 화살표로 표시한 것이고,<br />
그림 (c)는 각 구역을 정점 하나로 표현하고, 인접한 구역끼리 간선으로 연결한 그래프이며, <br />
그림 (d)는 (c)의 그래프를 다시 보기 좋게 그린 것 이다.<br />

- 색칠 문제는 k개의 색상을 사용해서 인접한 정점은 같은 색상이 칠해지지 않도록 <br />
그래프를 칠할 수 있는지 묻는다. 

<img width="349" alt="그림 14-5 지도 색칠 문제의 예" src="https://user-images.githubusercontent.com/40673012/98877154-2a30dc80-24c3-11eb-89b7-5def50d50579.png">

### 알고리즘 14-2 색칠 물제를 위한 백트래킹 알고리즘
```
// i: 정점, c: color
// 질문: 정점 i-1까지는 제대로 칠이 된 상태에서 정점 i를 색상 c로 칠하려면 k개의 색으로 충분한가?
kColoring(i,c){
    if(valid(i, c) then {
        color[i]<-c;
        if(i = n) then {return TRUE;}
        else {
            result <- FALSE;
            d<-1;   // d: color 
            while(result=FALSE and d<=k){
                result <- kColoring(i+1,d); // i+1 : 다음 정점
                d++;
            }
        }
        return result; 
    }else {return FALSE;}
}

// i: 정점, c: color
// 질문: 정점 i-1까지는 제대로 칠이 된 상태에서 정점 i를 색상 c로 칠하면 이들과 색이 겹치지 않는가? 
valid(i, c){ 
    for j<-1 to i-1{
        //정점 i와 j 사이에 간선이 있고, 두 정점이 같은 색상히면 안 된다.
        if((i, j) ∈ E and color[j] = c) then return FALSE;
    }
    return TRUE;
}
```

- 알고리즘 14-2는 k개의 색상으로 그래프를 칠할 수 있는지 체크하는 백트래킹 알고리즘이다. <br />
칠해야 할 정점의 `총수`는 n이다. 
- `최초`에는 kColoring(1,1)을 호출한다.  kColoring(i,c)를 호출하는 시점에는 정점 1부터 i-1까지가 <br /> 
k개 또는 그 이하의 색상으로 칠해져 있다. <br />

- 이 상태에서 정점 i에 색상 c를 칠하고 끝까지 칠하고 끝까지 잘 마무리할 수 있는지 조사하는 알고리즘이다.  <br />
우선 정점 i에 색상 c를 칠하면 지금까지 칠해놓은 정점들과 색이 `충돌`하지 않는지 체크한다. <br />
이를 위해 정점 i에 `인접`하면서 이미 칠해진 정점 중 색상 c로 칠해진 정점이 있는지 확인한다.  <br />
`valid(i, c)`가 이 일을 한다.  <br />

- 이 단계를 통과하면 다음 과정을 진행한다. 정점 i가 `마지막 정점`이면 성공적으로 완료되었음을 선언한다. <br />
i가 n번째 칠이 된 정점의 경우가 이 경우이다. <br />
정점 i가 마지막 정점이 아니면 다음 정점을 하나 선택해 색상을 하나씩 칠해보는 과정을 `반복`한다.

![그림 14-6 알고리즘 14-2의 작동 과정에 대응되는 상태 공간 트리](https://user-images.githubusercontent.com/40673012/98892279-5ceacd00-24e3-11eb-9f09-b49ceb608f74.png)

- 그림 14-6은 그림 14-5의 (d) 그래프를 세 가지 색으로 칠할 수 있는 지 알고리즘 14-2를 사용해서 체크하는 과정을 `상태 공간 트리`로 나타낸 것
- 각 노드에 표시된 2개의 수는 함수 `kColoring()`의 두 입력 값을 나타냄
    - 예: 5번 노드는 (3,2)로 표시되었는데 함수 호출 kColoring(3,2)를 나타냄
- 각 노드의 왼쪽 위의 작은 원에 표기된 수는 각 노드가 `방문된 순서`를 나타냄
- X로 표시된 노드들은 해당 `함수 호출`이 `FALSE`로 끝난 경우임 
    - 예: 4번 노드는 함수 호출 kColoring(3, 1)은 FALUSE로 끝나 더 이상 진행되지 못했음을 나타냄<br />
    
- 대부분 백트래킹은 그리 `효율적인 선택이 아니지만`, 이런 식으로 가지치기가 일어나므로 <br />
원시적인 방법으로 모든 경우의 수를 확인하는 알고리즘은 아니다.


## 3 한정 분기
- 그림 14-3과 같은 사전식 탐색은 경우의 수가 n-1에 비례해서 늘어나므로 정점의 수 n이 조그만 커져도 탐색이 어려움
    - n이 27 이상이면, 펜티업 3GHz CPU로 10조 년 이상 소요
- 이 탐색 과정을 살펴보면 상당한 비율의 정점을 방문하지 않아도 된다는 사실을 발견할 수 있음. <br />
어떤 부분 경로의 길이가 지금까지 찾아놓은 `가장 좋은 해를 초과하면`, 더 이상 진행을 해보아야 희망이 없기 때문임.
`TSP 한정 분기 방법`은 이 원리를 조금 더 개량해서 보지 않아도 될 정점 수를 최대한 늘림. <br />

- `한정 분기`(Branch and Bound)는 1960년 랜디와 도이가 제안한 방법으로 처음에는 선형 계획법을 해결하기 위해 제시됨. 
의미: 분기를 한정적으로 해서 쓸데없는 시간 낭비를 줄이는 방법<br />

### 한정 분기를 위한 두 가지 요소
- 1. 모든 경우의 수를 나열
- 2. 분기를 더 이상 할 필요가 없음을 판단할 수 있는 방법을 제공
    - 최적해를 찾을 가능성이 없으면 더 이상 진행하지 않고 다음 후보를 찾음
    - 이것을 `가지치기`, 영어로 Prunning이라 함
    
### 가지치기의 원리
- 어느 시점에 가능한 선택이 여섯 가지가 있다 하면, <br />
이 중 세 가지는 선택을 해도 최적해를 찾을 확률이 0임을 알 수 있으면 이들은 선택 대상에서 제외 할 수 있음(그림의 검은색). 

<img width="402" alt="그림14-7 가지치기의 원리를 설명하는 그림" src="https://user-images.githubusercontent.com/40673012/99139967-d7048880-2680-11eb-8a67-e6e9f56697a2.png">

- 지금까지 찾은 가장 좋은 해의 품질이 좋을수록 탐색 수가 작아진다. <br />
즉, 가지치기가 더 많이 일어나 시간을 절약할 수 있다. <br />
때문에 한정 분기에서 `초기에 좋은 해를 찾는 것이 유리`하다. 

- 최악의 경우: 초기에 나쁜 해가 나오고 점차 해가 개선되는 경우, 거의 모든 해를 찾아보아야 한다.

### 한정 분기 탐색
- 아래 그림은 그림 14-3의 TSP 예를 대상으로 한정 분기 탐색을 하는 과정을 트리로 나타낸 것이다.
- `노드 내 수열`은 부분 경로다. <br />
- `노드 옆의 괄호 안에 있는 수`는 해당 경로로 계속 진행하여 경로를 완성했을 때 얻을 수 있는 <br />
경로 길이의 `하한 값`을 나타낸다. 
    - 즉, 그 경로를 확장해서 모든 정점을 방문하는 사이클을 만들면 길이가 적어도 그만큼은 된다
- `괄호 아래에 "+"로 연결된 두 수`는 이 하한성이 계산된 근거를 보인다. 
    - 예: 6번 노드에 표시된 "24+13"은 지나온 경로 1-2-3의 길이가 24이고, <br />
    이후 경로를 아무리 잘 완성해도 최소한 길이 13은 더 필요함을 의미한다. 따라서 이 경로의 하한 값은 37.
- `각 리프 아래의 네모 안에 있는 수`는 사이클을 완성했을 때 실제 길이다. <br />
`네모 위`에는 해당 사이클의 정점들이 순서대로 모두 나열된다.<br />

#### 하한 값을 구하는 방법
- 각 정점에서 다른 정점에 이르는 간선들의 길이 중 가장 짧은 값을 다음과 같이 구한다. <br />
이것으로 최적해는 적어도 10+10+7+3+3=33보다 작을 수 없음을 알 수 있다. 
    - 정점 1: 10(정점 1에서 나가는 간선들의 길이 10, 10, 30, 25 중 최솟값)
    - 정점 2: 10(정점 2에서 나가는 간선들의 길이 10, 14, 21, 10 중 최솟값)
    - 정점 3: 7(정점 3에서 나가는 간선들의 길이 10, 18, 7, 9 중 최솟값)
    - 정점 4: 3(정점 4에서 나가는 간선들의 길이 8, 11, 7, 3 중 최솟값)
    - 정점 5: 3(정점 5에서 나가는 간선들의 길이 14, 10, 10, 3 중 최솟값)

- 해밀토니안 사이클에는 각 정점에서 다른 정점으로 연결되는 간선이 하나씩 있으므로 n개의 간선이 있다. <br />
위의 값 33은 각 정점에서 나가는 가장 짧은 간선들만 조합한 것이므로, <br />
합법적인 사이클이 될 가능성은 희박하다. 최적해는 이보다 다소 클 것이다. <br />
`하한 값의 측정`이 정밀할수록 한정 분기 알고리즘의 효율성은 좋아진다. <br />

- 6번 노드의 예를 들면, 지금까지 진행된 것이 경로 1-2-3이므로, <br />
정점 3에서 나가는 간선 중 최소치인 7, 정점 4에서 나가는 간선 중 최소치인 3, 
정점 5에서 나가는 간선 중 최소치인 3을 더하면 13이 된다. <br />
즉, 앞으로 경로를 완성하기 위해 최소한 길이 13은 더 필요하다. <br />

- 그림 14-8은 모든 정점을 방문하고 돌아오는 사이클이므로 시작점을 정점 1로 고정해도 상관없다. <br />
각 노드 왼쪽의 1), 2) 등 표시는 트리에서 각 노드가 방문된 순서다.
- 단, 노드에 대응되는 `부분 경로의 길이가 계산`되는 것과 `노드가 방문`되는 것은 다르다.<br />

- 1) 노드 1은 시작 정점만 정해놓고 출발을 안 한 상태이므로 하한 값은 각 정점에서 나가는 간선 중 최솟값들을 더한 값이다. <br />
즉 10+10+7+3+3=33이다. 이제 부분 경로 1-2, 1-3, 1-4, 1-5 각각에 대해 하한 값을 구한다. <br />
`부분 경로 1-2`는 간선 (1,2)의 길이가 10이므로 이 부분 경로를 거치는 모든 해밀토니안 사이클의 하한 값은 여전히 33이다. <br />
`부분 경로 1-3`도 마찬가지다. <br />
`부분 경로 1-4`의 경우 간선 (1, 4)의 길이가 30이므로 30+(10+7+3+3)=53이 되어 이 부분 경로를 거치는 모든 해밀토니안 사이클의 하한 값은 적어도 53은 된다. <br />
`부분 경로 1-5`의 경우 하한 값이 48이 된다. <br />
이 중 하한 값이 가장 작은 것부터 탐삭한다. 따라서 `부분 경로 1-2`를 선택한다. <br />
    
- 2) 부분 경로 1-2에서 정점을 하나 더 방문해 만들 수 있는 부분 경로는 1-2-3, 1-2-4, 1-2-5 로 3개다. <br />
이들의 하한 값은 각각 37, 44, 33이다.
- 3) 이 중 하한 값 33을 가진 부분 경로 `1-2-5`부터 탐색한다.
- 4) 부분 경로 `1-2-5-3`은 해밀토니안 사이클 `1-2-5-3-4-1`을 만들 수밖에 없다. <br />
이 사이클의 길이는 45다. 이것을 `기준 값`(지금까지의 최소 사이클 길이)으로 잡는다.
- 5) 다음으로 부분 경로 `1-2-5-4`는 해밀토니안 사이클 `1-2-5-4-3-1`을 만들 수밖에 없고, 길이는 40다. <br />
앞에서 잡은 기준 값 45보다 작으므로 이것으로 기준 값을 `갱신`한다.
- 6) 다음으로 부분 경로 `1-2-3`을 택한다. 이것으로 만들어지는 해밀토니안 사이클은 2개뿐이다.
- 7) 사이클 `1-2-3-4-5-1`은  길이가 48이다. 기준값 40보다 크므로 의미 없다.
- 8) 사이클 `1-2-3-5-4-1`은  길이가 48이다. 기준값 40보다 크므로 의미 없다.
- 9) 다음으로 부분 경로 `1-2-4`인데 하한 값이 44이다. 기준 값 40보다 크므로 의미 없다.
- 10) 다음으로 부분 경로 `1-3`으로 간다. 하향 값은 33이다. 이것으로 만들어질 수 있는 <br />
세 부분 경로의 하한 값은 각각 44, 33, 35이다.
- 11) 하한 값 33을 가진 부분 경로 `1-3-4`를 탐색한다. 이로부터 만들어지는 해밀토니안 사이클은 두개다. 
- 12) 사이클 `1-3-4-2-5-1`은 길이가 22이다. 기준값 40보다 크므로 의미 없다.
- 13) 사이클 `1-3-4-5-2-1`은 길이가 40이다. 기준값과 같으므로 갱신하지 않는다.
- 14) 다음으로 부분 경로 `1-3-5`를 탐색한다. 이로부터 만들어지는 해밀토니안 사이클은 두개다.
- 15) 사이클 `1-3-5-4-3-2`은 길이가 43이다. 기준값 40보다 크므로 의미 없다.
- 16) 사이클 `1-3-4-5-2-1`은 길이가 40이다. 기준값과 같으므로 갱신하지 않는다.
- 17) 다음으로 부분 경로 `1-3-2`인데 길이가 43이다. 기준값 40보다 크므로 의미 없다.
- 18)  다음으로 부분 경로 `1-5`인데 길이가 48이다. 기준값 40보다 크므로 의미 없다.
- 19) 마지막으로 부분 경로 `1-4`인데 길이가 53이다. 기준값 40보다 크므로 의미 없다. <br />
더 이상 볼 경로가 남아 있지 않으므로 알고리즘이 끝난다. <br />

- 정점이 5개인 이 TSP 예의 경우 가지치기를 하지 않으면 살펴보아야 할 해밀토니안 사이클의 총수는 24개이다. <br />
하지만 가지치기로 8개의 리프 노드만 보고 탐색을 끝냈다.
- 그림 14-8은 `DFS 방식의 탐색`이다. <br />
상황에 따라 BFS 방식으로 분기 한정을 수행하는 것도 가능한데 TSP 문제의 경우 적합하지 않다.
- 그림에서 리프 노드 아래 네모 중 별색으로 칠해진 것은 `최솟값 갱신`이 일어난 경우다.
- `초반의 해들은 품질`이 대체로 나쁘다. 기준 값이 점점 작아지므로 가지치기의 비율이 뒤로 갈수록 점점 높아진다. <br />
시간을 더 단축할 수 있는 한 가지 방법은 시작 전에 시중에 있는 품질이 괜찮은 `휴리스틱 알고리즘`을 하나 사용해서<br />
해를 구한 다음 이것을 기준 값으로 삼는 것이다.

<img width="500" alt="그림14-8 그림 14-3의 TPS를 대상으로 한 한정 분기 탐색의 예" src="https://user-images.githubusercontent.com/40673012/99139966-d53ac500-2680-11eb-8351-a76b8500618c.png">

