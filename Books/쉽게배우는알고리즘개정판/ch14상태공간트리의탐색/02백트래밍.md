# 02 백트래킹
- 백트래킹은 DFS와 같은 방식으로 탐색하는 모든 방법을 뜻함
    - 탐색을 하다가 더 갈 수 없으면 왔던 길을 되돌아가 다른 길을 찾는다고 해서 이른 이름이 붙음

## 특징
1. 주로 재귀적으로 구현 <br />
2. 기본적으로 모두 DFS 범주에 속함 (조금씩 변형은 일어남) <br />
3. 백트래킹 알고리즘이 상태 공간 트리를 명시적으로 만드는 것은 아니지만, <br />
알고리즘의 진행 과정은 `상태 공간 트리 루트`에서 시작해서 `DFS 방식`으로 탐색을 해나가는 것과 대응

## 1 미로 찾기 문제
- 그림 (a)는 주어진 미로이며, S는 시작 지점, T는 목표 지점 
- 그림 (b)는 이 미로를 탐색하다가 선택을 해야 하는 지점, 즉 분기점들을 정점으로 나타낸 것
- 그림 (c)는 미로 찾기 문제의 탐색 과정을 상태 공간 트리로 표현한 것 

### (c)의 상태 공간 트리 설명
- S에서 시작해 정점 1로 이동한다. 정점 2 또는 3 중 하나를 선택할 수 있다.
- 임의로 정점 2를 선택한다. 2에 도착하여 막다른 골목임임을 안다.
- 정점 2로 오는데 거쳤던 중간 지점 1로 돌아온다. 
- 정점 3으로 이동한다. 정점 4 또는 5 중 하나를 선택할 수 있다. 정점 5를 선택한다.
- 정점 5로 이동하다. 정점 6과 7 중 하나를 선택할 수 있다. 정점 6을 선택한다.
- 정점 6으로 이동한다. 막다른 골목임을 알게 된다.
- 정점 6으로 오기 위해 거친 중간 지점 5로 돌아온다. 
- 정점 7로 이동한다. 정점 8, 10 T 중 하나를 선택할 수 있다. 정점 T를 선택한다.
- 정점 T에 도착하여 목표 지점임을 안다. 탐색을 끝낸다. <br />

- 백트래킹은 이렇게 가보고 되돌아오고를 반복하는 것
- 운이 좋으면 시행착오를 덜 거치고 목적지에 도착할 것이고, 최악의 경우에 모든 경우를 다 거친 다음 목적지에 도착함
- 그림 (c)에서 ●, ◼︎으로 나타낸 부분은 운 좋게 가보지 않고 탐색을 끝낸 노드들이다.

<img width="389" alt="그림 14-4 미로 찾기 문제와 이를 상태 공간 트리로 나타낸 예" src="https://user-images.githubusercontent.com/40673012/98877276-6e23e180-24c3-11eb-8b8a-961b04df948d.png">


### 알고리즘 14-1 미로 찾기 문제를 위한 백트래킹 알고리즘
- 알고리즘이 끝난 후 S에서 T에 이르는 경로를 알려면, <br />
T에서 시작해 prev[]를 통해 따라가면 S에 이른다. 이의 역방향이 해답 경로다. 이 알고리즘은 사실상 `DFS`와 같다.
```
maze(v){
    visited[v] = YES;
    if(v=T) then {return "성공";} //끝내기
    for each x ∈ L(v)
        if (visited[x] = NO) then {
            prev[x]<-v;
            maze(x);
        }
}
```

## 2 색칠 문제
- 그림 14-5는 그래프의 색칠 문제다. <br />
그림 (b)는 서로 인접한 구역을 화살표로 표시한 것이고,<br />
그림 (c)는 각 구역을 정점 하나로 표현하고, 인접한 구역끼리 간선으로 연결한 그래프이며, <br />
그림 (d)는 (c)의 그래프를 다시 보기 좋게 그린 것 이다.<br />

- 색칠 문제는 k개의 색상을 사용해서 인접한 정점은 같은 색상이 칠해지지 않도록 <br />
그래프를 칠할 수 있는지 묻는다. 

<img width="349" alt="그림 14-5 지도 색칠 문제의 예" src="https://user-images.githubusercontent.com/40673012/98877154-2a30dc80-24c3-11eb-89b7-5def50d50579.png">

### 알고리즘 14-2 색칙 물제를 위한 백트래킹 알고리즘
```
// i: 정점, c: color
// 질문: 정점 i-1까지는 제대로 칠이 된 상태에서 정점 i를 색상 c로 칠하려면 k개의 색으로 충분한가?
kColoring(i,c){
    if(valid(i, c) then {
        color[i]<-c;
        if(i = n) then {return TRUE;}
        else {
            result <- FALSE;
            d<-1;   // d: color 
            while(result=FALSE and d<=k){
                result <- kColoring(i+1,d); // i+1 : 다음 정점
                d++;
            }
        }
        return result; 
    }else {return FALSE;}
}

// i: 정점, c: color
// 질문: 정점 i-1까지는 제대로 칠이 된 상태에서 정점 i를 색상 c로 칠하면 이들과 색이 겹치지 않는가? 
valid(i, c){ 
    for j<-1 to i-1{
        //정점 i와 j 사이에 간선이 있고, 두 정점이 같은 색상히면 안 된다.
        if((i, j) ∈ E and color[j] = c) then return FALSE;
    }
    return TRUE;
}
```

- 알고리즘 14-2는 k개의 색상으로 그래프를 칠할 수 있는지 체크하는 백트래킹 알고리즘이다. <br />
칠해야 할 정점의 `총수`는 n이다. 
- `최초`에는 kColoring(1,1)을 호출한다.  kColoring(i,c)를 호출하는 시점에는 정점 1부터 i-1까지가 <br /> 
k개 또는 그 이하의 색상으로 칠해져 있다. <br />

- 이 상태에서 정점 i에 색상 c를 칠하고 끝까지 칠하고 끝까지 잘 마무리할 수 있는지 조사하는 알고리즘이다.  <br />
우선 정점 i에 색상 c를 칠하면 지금까지 칠해놓은 정점들과 색이 `충돌`하지 않는지 체크한다. <br />
이를 위해 정점 i에 `인접`하면서 이미 칠해진 정점 중 색상 c로 칠해진 정점이 있는지 확인한다.  <br />
`valid(i, c)`가 이 일을 한다.  <br />

- 이 단계를 통과하면 다음 과정을 진행한다. 정점 i가 `마지막 정점`이면 성공적으로 완료되었음을 선언한다. <br />
i가 n번째 칠이 된 정점의 경우가 이 경우이다. <br />
정점 i가 마지막 정점이 아니면 다음 정점을 하나 선택해 색상을 하나씩 칠해보는 과정을 `반복`한다.

![그림 14-6 알고리즘 14-2의 작동 과정에 대응되는 상태 공간 트리](https://user-images.githubusercontent.com/40673012/98892279-5ceacd00-24e3-11eb-9f09-b49ceb608f74.png)

- 그림 14-6은 그림 14-5의 (d) 그래프를 세 가지 색으로 칠할 수 있는 지 알고리즘 14-2를 사용해서 체크하는 과정을 `상태 공간 트리`로 나타낸 것
- 각 노드에 표시된 2개의 수는 함수 `kColoring()`의 두 입력 값을 나타냄
    - 예: 5번 노드는 (3,2)로 표시되었는데 함수 호출 kColoring(3,2)를 나타냄
- 각 노드의 왼쪽 위의 작은 원에 표기된 수는 각 노드가 `방문된 순서`를 나타냄
- X로 표시된 노드들은 해당 `함수 호출`이 `FALSE`로 끝난 경우임 
    - 예: 4번 노드는 함수 호출 kColoring(3, 1)은 FALUSE로 끝나 더 이상 진행되지 못했음을 나타냄<br />
    
- 대부분 백트래킹은 그리 `효율적인 선택이 아니지만`, 이런 식으로 가지치기가 일어나므로 <br />
원시적인 방법으로 모든 경우의 수를 확인하는 알고리즘은 아니다.


##
