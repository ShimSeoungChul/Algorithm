# 1 선택 정렬(Selection Sort)
- 원리가 간단한 정렬 알고리즘 중 하나다
- 1. 배열 A[1...n]에서 가장 큰 원소를 찾아 이 원소와 배열의 끝자리에 있는 A[n]과 자리를 바꾼다. <br />
방금 맨 뒷자리로 옮긴 원소, 즉 가장 큰 원소는 자기 자리를 찾았으므로 더 이상 신경 쓰지 않는다.
- 2. 이 원소를 제외한 나머지 원소들로 같은 작업을 반복한다.

## 알고리즘
```
selectionSort(A[],n) //A[1...n]을 정렬한다.
{
    1) for last <- n downto 2{
      2) k<-theLargest(A, last);//A[1...last] 중 가장 큰 수 A[k]를 찾는다;
      3) A[k] <-> A[last]; //A[k]와 A[last]의 값을 교환
    }  
}
theLargest(A[], last)//A[1...last]에서 가장 큰 수의 인덱스를 리턴
{
    largest<-1;
    for i<-2 to last
        if(A[i]>A[largest]) then largest<-i;
    return largest;
}
```

- 1)에서 변수 last는 정렬한 배열의 맨 마지막 인덱스, 즉 배열의 크기를 나타낸다. <br />
처음에는 배열의 크기가 n으로 시작하므로 A[1...n]을 정렬 대상으로 삼는다. <br />
가장 큰 수를 찾아 제자리에 놓을 때마다 last는 1씩 줄어든다.<br />

- 1)의 for 루프는 정렬할 배열의 크기를 한 번에 하나씩 줄여나가는 역할을 한다. <br />
즉, 맨 처음 배열의 크기가 n으로 시작하여, 그다음 루프에서는 n-1(정렬할 배열은 A[1...n-1]이 된다), n-2, 이렇게 계속 작아진다. <br />
마지막에는 크기 2인 배²열 A[1...2]의 두 원소 중 큰 원소를 A[2]에 놓고 나면 A[1]에는 제일 작은 원소가 자리잡게 되므로 정렬이 끝난다.

## 예
<img width="338" alt="선택 정렬" src="https://user-images.githubusercontent.com/40673012/94077128-cb42d580-fe38-11ea-9f11-6dc829a5f22c.png">

## 수행 시간
- 선택 정렬의 수행 시간은 모든 경우에 Θ(n²)이다.
    - 1)의 for 루프는 n-1번 순환한다. 3)은 단순히 두 수를 교환하는 것이므로 상수 시간이 든다.
    - 2)는 각 부분 배열에서 가장 큰 수를 찾는 작업이므로 시가는 부분 배열의 크기에 비례한다 <br />
    (크기가 k인 배열에서 가장 큰 수를 찾는 데 k-1의 비교가 필요하다)
    - 부분 배열의 크기는 1)의 for 루프에서 n부터 시작해서 2까지 감소한다. <br />
    그러므로 수를 비교하는 총 횟수는 (n-1) + (n-2) + ... + 2 + 1 = n(n-1)/2, 즉 Θ(n²)이다. <br />
    여기서는 수를 비교하는 횟수가 전체 시간을 좌우하므로 이것을 기준으로 분석한다.


# 2 버블 정렬(Bubble Sort)
- 선택 정렬처럼 제일 큰 원소를 끝자리로 옮기는 작업을 반복한다. <br />
다만 제일 큰 원소를 오른쪽으로 옮기는 방법이 다르다.

## 알고리즘
``` 
bubbleSort(A[], n) //A[1...n]을 정렬한다.
{
    1) for last <- n downto 2
       2) for i<-1 to last-1
         3)  if(A[i]>A[i+1]) then A[i] <->A[i+1]; //원소 교환
}
```
- 알고리즘은 크게 두 개의 for 루프로 구성된다.
- 1)의 for 루프는 선택 정렬의 for 루프와 역할이 같다. <br />
루프를 돌 때마다 제일 큰 원소를 맨 오른쪽으로 보내고 정렬할 배열의 크기를 하나씩 줄인다. <br />

- 2) for 루프, 즉 안쪽 for 루프는 가장 큰 원소를 맨 오른쪽을 보낸다. 이 부분이 선택 정렬과 다르다.<br />
선택 정렬이 가장 큰 수를 찾은 다음 맨 오른쪽 수와 바꾸는 반면, <br />
버블 정렬은 왼쪽부터 이웃한 수를 비교하면서 순서가 제대로 되어 있지 않으면 하나하나 바꾸어나간다.

## 예
<img width="553" alt="버블정렬" src="https://user-images.githubusercontent.com/40673012/94077648-f0374880-fe38-11ea-8e92-048c9b5a0ffe.png">

## 수행 시간
- 1)의 for 루프는 선택 정렬에서처럼 n-1번 순환한다.
- 2)의 for 루프는 last-1번 순환한다. <br />
last가 n에서 2까지 1씩 감소하므로 2)의 for 루프가 총 순환하는 횟수는 (n-1)+(n-2)+...+2+1=n(n-1)2이다.<br />
이것이 알고리즘의 시간을 좌우한다. 
- 3)은 상수 시간 작업이다. 따라서 버블 정렬의 수행 시간은 Θ(n²)이다.

## 꿀팁
- 버블 정렬 알고리즘은 알고리즘이 수행을 시작할 때나 중간에 배열이 이미 정렬되어 있는 상태라도<br /> 
계속 끝까지 무의미한 순환을 계속한다. 이를 위해 알고리즘에 한가지 장치를 하는 방법이 있다.

```
bubbleSort(A[],n){
    for last<-n downto 2{
        sorted<-TRUE;
        for i<-1 to last-1{
            if(A[i]>A[i+1]) then{
                A[i]<->A[i+1]; //원소 교환
                sorted<-FALSE:
            }
        }
        if (sorted=TRUE) then return;
    }
}
```
- 2)의 for 루프가 시작되기 직전 매번 sorted라는 표식자를 TRUE로 설정해두고,<br />
이것이 2)의 for 루프를 도는 동안 변하는지 본다. <br />
중간에 한 번이라도 A[i] <-> A[i+1]의 교환이 일어나면 FALSE로 바뀐다.<br />
이것이 바뀌지 않았으면 2)의 for 루프를 도는 동안 한 번도 교환이 일어나지 않았으므로 배열은 이미 정렬된 상태다.<br />
이때는 3)에서 리턴해서 알고리즘을 끝낸다.<br />

- 이렇게 할 경우 배열이 정렬된 상태로 입력되면 버블 정렬은 1)의 for 루프를 첫 번째 순환하고 리턴하여 끝난다.<br /> 즉, Θ(n)의 시간이 소요된다.


# 3 삽입 정렬(Insertion Sort)
- 삽입 정렬은 이미 정렬되어 있는 i 크기의 배열에 하나의 원소를 더하여 <br />
정렬된 i+1 크기의 배열을 만드는 과정을 반복한다.
- 선택 정렬과 버블 정렬이 n개짜리 배열에서 시작하여 그 크기를 하나씩 줄이는 데 반하여, <br />
삽입 정렬은 한 개짜리 배열에서 시작하여 그 크기를 하나씩 늘리는 정렬이다.

## 알고리즘
```
insertionSort(A[],n) //A[1...n]을 정렬한다.
{
    1) for i <- 2 to n
        2) A[1...i]의 적합한 자리에 A[i]를 삽입한다;
}
```

- 1)의 for 루프는 문제의 크기를 하나씩 키워나가는 역할을 한다. <br />
이 알고리즘에서 A[i]에 관심을 두는 시점, 즉 2)를 수행하기 직전 시점에 A[1 ... i-1]은 항상 정렬 되어 있다. <br />

- 2)를 수행하고 나면 A[i]까지 정렬이 된다. <br />
즉, 이미 정렬된 A[1 ... i-1]과 원소 A[i]를 받아 정렬된 배열 A[1 ... i]를 만든다. <br />
A[i]가 A[i-1]보다 크면 A[i]는 A[1 ... i-1]에 있는 모든 원소보다 크므로 A[i]는 그냥 제자리에 둔다. <br />
그렇지 않으면 A[i-1]부터 시작해서 왼쪽으로 차례로 훑으면서 A[i]가 들어갈 자리를 찾는다. <br />
A[i]가 들어가는 자리부터 시작해서 이후의 원소들은 한 칸씩 오른쪽으로 밀려난다.

- 위 알고리즘을 좀 더 자세히 풀어서 쓰면 다음과 같다.
```
insertionSort(A[],n)
{
    1) for i<-2 to n{
        loc<-i-1;
        newItem<-A[i];
        //이 지점에서 A[1...i-1]은 이미 정렬되어 있는 상태
     2)   while(loc>=1 and newItem<A[loc]){
            A[loc+1]<-A[loc];
            loc--;
        }
        
        A[loc+1]<-newItem;
    }
}
```

## 예
<img width="341" alt="삽입정렬" src="https://user-images.githubusercontent.com/40673012/94078630-312f5d00-fe39-11ea-877f-a0573c708a7c.png">

## 수행 시간
- 1)의 for 루프는 n-1번 순환한다.
- 매 for 루프에서 2)의 while 루프는 최대 i-1번 순환한다. <br />
가장 운이 나쁘면 A[i]가 A[1] 자리에 들어가게 되어 i-1번의 순환이 필요하다. <br />
가장 운이 좋으면 A[i]가 제자리에 그대로 있게 되어 while 루프는 한 번도 수행되지 않는다.<br />

- 그러므로 최악의 경우 수행 시간은 1+2+...+(n-1) = n(n-1)/2, 즉 Θ(n²)이다. <br />
보통은 대략 A[1 ... i-1]에서 평균적으로 절반 정도를 훑고 끝나므로, <br />
전체 비교 횟수는 최악에 비해 절반 정도 되지만, 이 경우에도 여전히 Θ(n²)이다. <br />

## 삽입 정렬의 특징
- 삽입 정렬은 O(n²) 시간이 드는 비효율적인 정렬 알고리즘군에 속하지만, <br />
배열이 `거의 정렬`된 상태로 입력되는 경우 `가장 매력적인 알고리즘`이 된다. <br />
    - 완전히 정렬된 배열이 입력되면,  2)의 while 루프는 한 번도 수행되지 않으므로 <br />
    1)의 for 루프를 한 번 순환할 때마다 상수 시간이 소요된다. <br />
    1)의 for 루프는 n-1번 순환되므로 Θ(n)의 시간이 든다.
    - 버블 정렬에서는 이미 정렬된 배열에 무의미한 순환을 하는 낭비를 없애는 장치를 사용할 수 있지만,<br />
    이것을 검사하기 위해 사용한 여분의 코드 때문에 오버헤드가 생긴다. <br />
    이에 반해 삽입 정렬은 배열이 이미 정렬된 상태라면 특별한 장치 없이도 효율적으로 끝난다.<br />
    이러한 매력 때문에 많은 지능적인 프로그래머들이 다른 정렬을 사용하는 경우에도 상황에 따라 가끔 삽입 정렬을 섞어서 쓴다.
    
- 선택 정렬과 버블 정렬이 n개짜리 배열에서 시작하여 그 크기를 하나씩 줄여나가는데 반하여, <br />
삽입 정렬은 1개짜리 배열에서 시작하여 그 크기를 하나씩 늘려나간다. 
    - 좀 더 정확히 말하면, 선택 정렬과 버블 정렬이 n개짜리 배열에서 시작하여 `아직 정렬되지 않은 배열`의 크기를 하나씩 줄이는 데 반하여, <br />
    삽입 정렬은 1개짜리 배열에서 시작하여 `이미 정렬된 배열`의 크기를 하나씩 늘린다.
    


# 꿀팁 - Θ(n²)과 O(n²)의 차이

-  최악의 경우 Θ(n²)이라는 표현 대신에 최악의 경우 O(n²)이라는 표현을 쓸 수도 있지만 이는 정보를 충부히 전달하지 못한다 <br />
O(n²)은 반드시 n² 차수에 이를 필요는 없지만 Θ(n²)은 차수가 n²이라는 뜻이다<br />
최악의 경우에 n² 차수에 실제로 이른다면 최악의 경우 Θ(n²)이라고 하는 것이 정확한 표현이다.<br />
그냥 "최악의 경우"라는 말을 빼고 "수행 시간이 O(n²)"이라고 하더라도 어떤 경우든 n² 차수 이하라는 뜻이지 <br />
n² 차수에 실제로 이르는 경우가 있는지는 분명하지 않은 표현이다.


