
- 앞선 장의 기본 정렬 알고리즘은 모두 평균 Θ(n²)의 시간이 소요되었지만, <br />
이 절에서 배울 세 개의 알고리즘은 모두 평균 Θ(nlogn)의 시간이 소요된다 <br />

- 병합, 퀵, 힙 정렬을 소개하며 최악의 경우에도 병합 정렬과 힙 정렬은 Θ(nlogn)이 소요되고, <br />
퀵 정렬은  Θ(n²)이 소요된다. <br />

- 퀵 정렬은 최악의 경우 때문에 성능이 가장 나빠보일 수도 있으나 평균 성능은 어떤 정렬에도 뒤떨어지지 않아<br />
실무에서 가장 많이 사용된다


# 1 병합 정렬 (Merge Sort)
- 1. 입력을 반으로 나눈다
- 2. 나눈 전반부와 후반부를 각각 `독립적`으로 정렬한다
- 3. `정렬된 두 부분`을 `병합`하여 정렬된 배열을 얻는다
- 4. 여기서 전반부와 후반부를 정렬할 때도 역시 반으로 나눈 다음 정렬해서 병합한다.<br />
즉, 원래의 정렬 문제와` 성격이 똑같고 단지 크기만 반`으로 줄었을 뿐이다.<br />

- 병합 정렬은 자신에 비해 크기가 반인 문제를 두 개 푼 다음, 이들을 병합하는 일을 `재귀적`으로 반복한다.

## 알고리즘
```
mergeSort(A[],p,r)
{
    if(p<r) then{
        1) q<-|(p+r)/2|;   //p,r의 중간 지점 계산 
        2) mergeSort(A,p,q);   //전반부 정렬
        3) mergeSort(A,q+1,r); //후반부 정렬
        4) merge(A,p,q,r);     //병합
    }
}

merge(A[],p,q,r)
{
    //정렬되어 있는 두 배열 A[p...q]와 A[q+1...r]을 합쳐
    //정렬된 하나의 배열 A[p...r]을 만든다.
    
    i<-p,j<-q+1;t<-1;
    while(i<=q and j<=r){
        if(A[i]<=A[j])
        then tmp[t++]<-A[i++];  //의미:tmp[t]<-A[i];t++;i++;
        else tmp[t++]<-A[j++];  //의미:tmp[t]<-A[j];t++;j++;
    }
    while(i<=q)                 //왼쪽 부분 배열이 남은 경우 
        tmp[t++]<-A[i++];
    while(j<=r)                 //오른쪽 부분 배열이 남은 경우
        tmp[t++]<-A[j++];
    i<-p;t<-1;
    while(i<=r)                 //결과를 A[p...r]에 저장 
        A[i++] <- tmp[t++];
}
```

- 1) 배열을 이등분하기 위해 중간 지점을 계산한다
- 2), 3) 전반부와 후반부를 각각 독립적으로 정렬한다
- 4) 정렬된 전반부와 정렬된 후반부가 병합되어 하나의 정렬된 배열이 된다

## 예
- 병합 정렬의 작동 과정
<img width="329" alt="스크린샷 2020-09-20 오전 9 53 53" src="https://user-images.githubusercontent.com/40673012/93691932-45b4e200-fb27-11ea-928e-7c9166b2b10b.png">


- 병합 과정
<img width="550" alt="스크린샷 2020-09-20 오전 9 50 59" src="https://user-images.githubusercontent.com/40673012/93691939-506f7700-fb27-11ea-8cff-1a43ae4c084f.png">


## 수행 시간
- T(n) <= a ( if n=1 )
- T(n) <= 2T(n/2) + cn ( if n > 1 ) <br />

- 상수 a는 크기가 1인 문제를 푸는 시간, 상수 c는 병합에 드는 시간을 충분히 잡아주기 위해 n에 곱하는 것이다. <br />
비교의 횟수만으로 수행 시간을 분석한다면 c=1로 충분하다. 어쨌든 병합은 선형 시간이 소요된다.<br />

- T(n/2)은 두 개의 작은 문제를 처리하는 비용, 즉 재귀적 호출과 관련된 비용이다. <br />
여기서 n=2ᴷ이라 가정하고(k는 음이 아닌 정수) 이것을 전개해보면 다음과 같다. (여기서 logn은 log₂n)을 의미한다.<br/><br/>
T(n)<= 2T(n/2) +cn
     <= 2(2T(n/4)+c*n/2) = cn = 2²T(n/2²) + 2cn
     <= 2²(2T(n/2³)+c*n/2²)+2cn = 2³T(n/2³) + 3cn
     ...
     <= 2ᴷT(n/2ᴷ) + kcn
     = nT(1) + kcn = an + cnlogn
     = Θ(nlogn) <br />

- 병합 정렬의 수행 시간은 최악의 경우 Θ(nlong)이 된다.

### n=2ᴷ이라고 가정한 이유
- 어떤 정수 n이든 n과 2n 사이에는 2ᴷ 모양인 수가 하나 있다. <br />
만일 n < 2ᴷ < 2n이라면 n = 2ᴷ으로 놓고 복잡도를 구하겠다는 것이다. <br />
- n과 2n은 크기가 두 배 차이 나는데 두 배 차이가 나는 입력에 대해서는 <br />
다항식 시간이 걸리는 모든 알고리즘은 같은 복잡도를 가진다. 왜냐하면 다음과 같기 때문이다. <br /> <br />

T(n) = Θ(nᴾ) (p는 상수) -> T(2n) = Θ((2n)ᴾ) = 2ᴾΘ(nᴾ) = Θ(nᴾ)  <br /> <br />

n과 2n 사이에 있는 2ᴷ은 당연히 이들과 같은 점근적 복잡도를 가진다. <br />
이것에는 T(n)이 단조 증가 함수라는 가정이 숨어 있다. <br />
즉, 큰 입력에 대해 수행되는 시간은 더 작은 입력에 대해 수행되는 시간 이상 소요된다는 것이다. <br />
이런 이유로 시간 분석에는 n = 2ᴷ으로 가정하는 것을 자연스럽게 받아들이자.

- 이것은 알고리즘의 수행 시간을 따지는 데 일번적인 방법으로 이것으로 일반성을 잃지도 않는다.
- 앞의 수행 시간을 계산할 때는 마스터 정리를 써서 바로 Θ(nlong)임을 알 수도 있다.

# 2 퀵 정렬 (Quick Sort)
-  `평균적으로 가장 좋은 성능`을 가져 현장에서 가장 많이 쓰는 정렬 알고리즘이다.

## 예 1
- 퀵 정렬 작동 과정
<img width="373" alt="분할의 작동 과정" src="https://user-images.githubusercontent.com/40673012/93692523-4cdfee00-fb2f-11ea-8ba3-706cbd2ebce8.png" style="max-width:100%;">

- 1. 첫째 줄에 정렬해야 할 원소가 10개인 배열이 주어진다. <br />
아무 원소나 기준원소로 삼아도 상관없는데 여기서는 맨 뒤에 있는 원소 15를 기준원소로 삼는다.
- 2. (a)에서 기준원소인 15를 중심으로 이보다 작은 원소들은 15의 왼쪽에, 나머지는 오른쪽에 재배치한다.
- 3. (b)에서 왼쪽의 원소 3개와 오른쪽 원소 6개를 각각 독립적으로 정렬한다.  <br />

- 기준원소 15는 왼쪽과 오른쪽의 정렬을 시작하기 전에 이미 제자리를 찾을 것으로, <br />
왼쪽 3개의 원소를 정렬할때나 오른쪽 6개의 원소를 정렬할 떄 모두 영향을 받지 않는다. <br />
왼쪽과 오른쪽의 정렬을 위해서는 재귀를 수행해서 다시 퀵 정렬을 사용한다. 

## 알고리즘
```
quickSort(A[],p,r) //A[p...r]을 정렬한다.
{
    1) if (p < r) then {
        2)  q<-partion(A,p,r);   //분할
        3)  quickSort(A,p,q-1); //왼쪽 부분 배열 정렬
        4)   quickSort(A,q+1,r); //오른쪽 부분 배열 정렬
    }   
}
partition(A[],p,r)
{
    //배열 A[p...r]의 원소들을 A[r]을 기준으로 양쪽으로 재배치하고, 
    //A[r]이 자리한 위치를 리턴한다.
}
```

- 1), 2) `기준원소`를 중심으로 양쪽으로 나눈다
- 3), 4) 두 개의 퀵 정렬을 `재귀적`으로 호출한다 <br />

- `병합 정렬`이 먼저 재귀적으로 작은 문제를 해결한 다음 후처리를 하는데 반해, <br />
`퀵 정렬`은 선행 작업을 한 다음 재귀적으로 작은 문제를 해결하면서 바로 끝낸다.<br />

- 기준원소를 중심으로 분할하는 방법은 여러 가지가 있고, 다음은 최근에 많이 쓰는 방식이다

```
partion(A[],p r)
{
    x<-A[r];    //기준원소
    i<-p-1;     //i는 1구역의 끝지점
    for j<-p to r-1
    if(A[j]<=x) then A[++i]<->A[j]; //의미는 i값 증가 후 A[i]<->A[j]교환
    
    A[i+1] <-> A[r];    //기준원소와 2구역 첫 원소 교환
    return i+1;
}
```

## 예 2

- 분할의 작동 과정 (위의 partion() 함수)
<img width="479" alt="퀵 정렬 작동 과정" src="https://user-images.githubusercontent.com/40673012/93692522-4b162a80-fb2f-11ea-9ab9-196e29c655bc.png" style="max-width:100%;">

-  배열의 맨 끝 15를 기준 원소로 잡는다. <br />
목표는 15보다 작거나 같은 원소는 15의 왼쪽, <br />
15보다 큰 원소는 15의 오른쪽에 재배치하는 것이다.<br />

- 알고리즘은 배열을 네 구역으로 나누어 관리한다. <br />
1구역: 15보다 `작거나 같은` 원소들 <br />
2구역: 15보다 `큰` 원소들 <br />
3구역: 아직 `정해지지 않은` 원소들 <br />
4구역: 15 `자신`<br />
변수 i는 `1구역의 끝`, 변수 j는 `3구역의 시작` 부분을(아직 보지 않은 원소 중 가장 앞) 가리킨다. <br />
2구역은 `이들의 사이`, 즉 1구역의 끝 바로 다음부터 3구역 시작 원소 바로 앞까지다.<br />

- 3구역에 있는 원소를 차례로 하나씩 보면서 1구역 또는 2구역에 포함시킨다. <br />
처음에는 아직 아무 원소도 보지 않았으므로 15를 제외한 모든 원소가 3구역에 속한다. <br />
for 루프를 한 번 돌 때 원소를 하나씩 보므로, j는 1씩 증가한다. <br />

- 각각의 for 루프에서는 3구역의 첫 번째 원소(A[j])를 15와 비교해 15보다 큰 경우 <br />
2구역에 포함시켜야 하므로 2구역이 한 칸 넓어져야 한다. <br />
이 경우 따로 해줄 일은 없지만, for 루프가 한 번 돌았으므로 j만 1 증가한다. <br />
i값 변동 없이 j가 1증가하므로 2구역이 한 칸 넓어진다. <br />
그림의 (a)에서 각 구역이 {8}, {31,48}, {73,...,65}, {15}로 나뉜 상황에서 for 루프를 한 번 돌면 <br />
73이 15보다 크므로 j가 저절로 1 증가하여 2구역이 한 칸 넓어져 각 구역이 그림의 (b)처럼 <br />
{8}, {31, 48, 73}, {11, ..., 65}, {15}로 됨을 볼 수 있다. <br />

- A[j]가 15보다 작거나 같으면 1구역에 속하는 원소이므로 1구역이 한 칸 넓어져야 한다. <br />
i값을 1증가시킨 다음 2구역의 첫 번째 원소와 3구역의 첫 번째 원소를 바꾼다. <br />
j값은 for 루프가 한 바퀴 돌았으므로 당연히 1 증가한다. <br />
i와 j가 같이 1씩 증가하므로 1구역만 한 칸 넓어진다. <br />
(b)의 상황에서 시작한 for 루프는 11을 만나게 되는데, 15보다 작으므로 i가 1 증가하면서 <br />
1구역이 한 칸 넓어져 각 구역이 그림의 (c)처럼 {8,11}, {48,73,31},{3,...,65},{15}로 됨을 볼 수 있다.<br />

- 그림에서 (d)로부터 2구역의 첫째 원소(73)와 15를 바꾸면 (e)처럼 분할이 끝난다. <br />
for 루프가 모두 끝나면 아직 보지 않은 원소가 없으므로 3구역은 없어지고,<br />
리턴 값은 15가 위치한 장소, 즉, p+3이 된다.<br />

## 분할 알고리즘의 성질
- 1. for 루프가 한 바퀴 돌 때마다 3구역이 한 칸씩 줄어든다.
- 2. for 루프가 한 바퀴 돌 때마다 1구역 또는 2구역 중 하나가 한 칸 늘어난다.
- 3. 2구역이 늘어날 때는 j만 1 증가한다.<br />
for 루프가 한 바퀴 돌 때마다 j는 1 증가하므로 2구역을 늘리기 위해서는 아무 일도 할 필요가 없다.
- 4. 1구역이 늘어날 때는 i와 j가 동시에 1 증가한다.

## 수행 시간
- 우선 분할은 배열을 왼쪽부터 끝까지 한 번 훑어나가는 작업이므로 Θ(n)의 시간이 든다. 
- best cases: 분할이 항상 반반씩 균등하게 될 때다. <br />
이때는 시간이 T(n) = 2T(n/2)+ Θ(n)이 되어 병합 정렬과 같은 모양이므로 Θ(nlogn)이 된다.<br />

- worst cases: 계속해서 한쪽은 하나도 없고 다른 쪽에 다 몰리도록 분할이 되는 경우다. <br />
이때는 시간이 T(n) = T(n-1)+Θ(n)이 되어 Θ(n²)이 된다. <br />
하지만 이런 불운한 경우가 반복될 확률은 아주 희박하다. <br />

- average cases: 평균 수행 시간은 분할했을 때 모든 가능한 경우의 수를 평균내면 된다. <br />
기준원소를 중심으로 n개의 원소를 분할했을 때  <br />
기준원소가 n개의 원소 중 작은 순서로 몇 등인지에 따라 분할의 모양이 결정된다. <br />
기준 원소가 1등이면 1구역과 2구역의 크기는 0:n-1, 2등이면 1:n-2, i등이면 i-1:n-i가 된다. <br />
이 경우의 수행시간은 T(n) = T(i-1) + T(n-i) + Θ(n) 이다. <br />
여기서  T(i-1), T(n-i) 는 재귀호출 비용이고  Θ(n)은 분할 비용이다. <br />
기준원소는 동일한 확률로 1등부터 n등 중의 하나가 되므로 이들을 평균하면 다음과 같이 된다.<br />

<img width="207" alt="퀵 정렬 평균 수행 시간" src="https://user-images.githubusercontent.com/40673012/93707601-11fbab80-fb6b-11ea-9dfd-61bf463e4a39.png">


- 그리고 이것을 계산하면 T(n) = Θ(nlogn)이 된다.


# 3 힙 정렬(Heap Sort)
- 힙이라는 특수한 자료구조를 사용하는 정렬 알고리즘이다. <br />
힙은 최소힙과 최대힙이 있으며, 값이 저장되는 방향만 반대일 뿐 성질은 똑같다.

## 3.1 힙 (최소힙으로 설명)
- 힙은 이진 트리로서 맨 아래 층을 제외하고는 완전히 채워져 있고, <br />
맨 아래층은 왼쪽부터 꽉 채워져 있다. <br />

- 힙의 모든 노드는 하나씩의 값을 갖고 있는데 다음 성질을 만족한다.<br />
각 노드의 값은 자기 자식의 값보다 작다(힙에 값이 같은 원소가 두 개 이상 있는 경우에는 "작다" 대신 "작거나 같다"). <br />

- 리프 노드는 자식이 없으므로 논리상 이 성질은 자동 만족된다. <br />
모든 노드가 이 성질을 만족하면, 이진 트리의 루트 노드에는 최솟값이 자리하게 된다. <br />
반대로 최대힙의 루트 노드에는 최댓값이 자리하게 된다. 

<img width="341" alt="힙과 관련된 예" src="https://user-images.githubusercontent.com/40673012/93708062-3e64f700-fb6e-11ea-8f96-e8bdf10f4410.png">

- 위 그림은 최소힙은 트리와 아닌 트리의 예를 보여준다. <br />
(a)는 모든 노드가 힙성질을 만족한다. <br />
(b)는 노드 8의 자식인 6이 8보다 더 작아 힙성질을 만족하지 않는다. <br />
(c)는 트리의 맨 아래층이 왼쪽부터 꽉 채워져 있지 않으므로 구조상 힙이 아니다.<br />

- `힙 정렬`은 먼저 주어진 배열을 힙으로 만든다. <br />
그런 다음 힙에서 가장 작은 값을 차례로 하나씩 제거하면서 힙의 크기를 줄여나간다. <br />
나중에 힙에 아무 원소도 남지 않으면 힙 정렬이 끝난다. <br />
정렬은 힙에서 원소들이 제거된 순서대로 한다.


## 3.2 힙 만들기

- 아래 그림 (a) 예에 있는 트리에서 부모자식 간의 관계를 나타내기 위해 보통의 트리를 표현할 때 쓰는<br />
`링크`나 `포인터` 같은 것을 사용해서 구현할 수도 있으나 <br />
꽉 찬 이진 트리이기 때문에 그렇게 하지 않고도 배열로 간단히 구현할 수 있다 <br />

- 아래 (b)는 (a)의 최소힙을 배열을 이용해 간단히 표현한 예다. <br />
우선 크기 n인 배열 A[1 ... n]을 잡는다. <br />
그림에서 원소가 6개 있으므로 A[1]부터 A[6]까지 순서대로 3, 6, 4, 8, 9, 7을 넣어주는 것으로 힙의 구성은 끝난다. <br />
이것은 꽉 찬 이진 트리의 멋진 성질을 이용한 것이다. <br />
A[1]은 구트, A[2], A[3]은 루트의 두 자식, A[4], A[5]는 A[2]의 두 자식, 이런식으로 부모자식 관계를 삼을 수 있다.<br />

- 일반적으로 A[k]의 자식은 A[2k]와 A[2k+1]이 된다. A[k]의 부모는 A[k/2]가 된다. <br />
이렇게 부모자식 관계를 배열의 인덱스를 사용해 간단히 계산할 수 있으므로 따로 링크, 포인터가 필요 없다.

<img width="417" alt="배열을 힙 구조로 보는 방법" src="https://user-images.githubusercontent.com/40673012/93708064-41f87e00-fb6e-11ea-960f-2d4a749aebb0.png">

- 정렬하고자 하는 n개의 원소를 가진 배열 A[1...n]이 주어지면, <br />
위 그림같이 부모자식 관계를 이용해 이를 꽉 찬 이진 트리로 해석할 수 있다. <br />
다만 값들이 힙성질을 만족하지 않고 제멋대로 들어 있다. <br />
이 트리가 힙성질을 만족하도록 노드의 값들을 재배치해서 힙으로 만든다. <br />

- 아래 그림은 임의의 배열을 받아 힙으로 만드는 과정을 보여준다

<img width="430" alt="임의의 배열을 힙으로 수선" src="https://user-images.githubusercontent.com/40673012/93708751-b41f9180-fb73-11ea-9cba-7571df712297.png">

- 그림(a) : 주어진 배열이다. 배열 A[1...6]에 수들이 아무렇게나 들어 있다.
- 그림(b) : 맨 뒤에서부터 따져 힙성질에 관하여 생길 수 있는 첫 번째 원소인 A[3]을 대상으로 체크한다.<br />
부모자식의 크기가 힙성질을 만족하지 않으므로 A[3]과 A[6]을 교환한다.
- 그림(c) : 힙성질에 과낳여 문제가 생길 수 있는 두 번째 원소인 A[2]를 대상으로 체크한다. <br />
A[2]가 두 자식 중 작은 값인 6보다 크므로 이들을 교환한다.
- 그림(d) : 힙 성질에 관하여 문제가 생길 수 있는 세 번째 원소인 A[1]을 대상으로 체크한다. <br />
A[1]이 두 자식 중 작은 값인 3보다 크므로 이들을 교환한다. 
- 그림(e) : 방금 교환해서 A[3]으로 내려온 7이 자식의 값 4보다 크므로 이들을 교환한다. <br />

### 알고리즘 4-7 (힙만들기)
```
buildHeap(A[],n)
{
1) for i <- ⌊n/2⌋ downto 1
    heapify(A, i, n);
    
}

heapify(A[],k,n)    // A[k]를 루트로 하는 트리를 힙성질을 만족하도록 수선
    // A[k]의 두 자식을 루트로 하는 서브 트리는 힙성질을 만족하고 있다.
    // n은 최대 인덱스(전체 배열의 크기)
{
    left <- 2k; right <- 2k+1;
    // 작은 자식 고르기. smaller: A[2k]와 A[2k+1] 중에 작은 원소
    if(right <= n) then{
        if(A[left] < A[right] then smaller <- left;
        else smaller <- right;
    }
    else if(left <=n) then smaller <- left; //k의 왼쪽 자식만 있는 경우
    else return;    //A[k]가 리프노드임으로 함수 종료
    
    //재귀적 조정
    if(A[smaller] < A[k] then){
        A[k]<-> A[smaller];     //교환
        heapify(A, smaller, n);
    }
    
}
```
- heapify(A, k, *)는 A[k]에 매달린 `두 서브 트리`가 힙성질을 만족하는 상태에서 <br />
`A[k]를 루트로 하는 서브 트리` 전체가 `힙성질`을 만족하도록 수선하는 함수다. <br />
우선 루트 노드를 제외하고는 모든 노드가 힙성질을 만족하고 있는 상태임을 유의하라. <br />

- 루트의 두 자식 중 작은 값을 x, 큰 값을 y라 할때 x와 루트를 비교한다. <br />
루트의 값이 x보다 크지 않으면, 힙성질이 만족되어 수선은 끝난다. <br />
루트의 값이 x보다 크면 x와 루트의 값을 맞바꾼다. <br />

- 이제 `x는 새로운 루트`가 되었고, 루트의 값은 한 단계 내려왔다. <br />
이 교환 후 x와 y 사이의 힙성질이 만족된다. <br />

- 이렇게 루트가 한 칸 아래로 내려온 노드를 r이라하고, <br />
다시 r을 새로운 루트로 삼아 이 작업을 재귀적으로 반복하여 내려갈 수 있는 곳까지 내려간다. 
<br />

- 중간에 루트가 자식 중 작은 값보다 크지 않은 경우를 만나면 중단한다.<br />

- 리프 노드는 그 자체로 힙성질을 만족하므로 buildHeap()은 리프가 아닌 노드 중 <br />
맨 뒤에서부터 루트로 삼아 heapify()를 수행한다. <br />
1)에서 [n/2]은 리프가 아닌 노드 중 맨 마지막 노드의 인덱스다. <br />
A([n/2])부터 A(1)까지 차례로 루트로 삼아 총 [n/2]번의 heapify()를 수행하면, <br />
A[1...n]은 힙성질을 만족한다.

### 수행시간
- buildHeap()에 소요되는 시간은 Θ(n)이다. 
- heapify는 해당 서브 트리의 높이가 시간을 좌우한다. <br />
어떤 서브 트리도 높이가 log₂n을 넘지 않으므로 heapify()를 한 번 수행하는데 O(logn)이 소요된다. <br />

- buildHeap()에서 heapify()를 호출하는 횟수는⌊n/2⌋이므로 전체적으로 O(nlogn)이 된다. <br />


- 그러나 이것은 좀 과하게 잡은 상한이다. <br />
모든 heapify()의 시간은 O(logn)으로 잡은 것은 다소 과하다. <br />
맨 처음 호출되는 heapify()의 입력 트리는 높이가 고작 1이고, 이런 것들이 꽤 여러 개 있다. <br />
그다음 레벨로 올라가면 높이가 2인 입력트리들을 만나고, <br />
더 올라갈수록 높이가 높은 부분 트리의 수는 줄어든다.<br />
이 경우의 수들을 합산하면  O(nlogn)이 아닌 Θ(n)이 된다.

## 3.3 정렬

- 루트 노드에 있는 원소를 제거하여 다른 곳에 저장한다. <br />
루트 노드가 없어졌으므로 트리의 크기가 하나 준다.<br />

- 맨 끝에 있는 원소를 루트 노드로 옮겨 새로운 루트로 삼는다.<br />
루트 노드에 옮긴 원소가 있던 자리에 방금 제거한 방금 제거한 루트 노드 원소를 저장하면 된다. <br />

- 이것으로 대부분의 경우 르트 노드와 자식 간의 힙 성질이 깨지므로 <br />
heapify()를 이용해 힙성질을 만족하도록 수선한다.<br />

- 아래 그림은 앞에서 만든 힙을 사용해 마지막 단계인 정렬을 하는 과정을 보여준다. <br />
별색으로 표시한 노드는 밤금 변동이 생긴 노드를 뜻한다.

<img width="430" alt="힙정렬 오후 5 33 09" src="https://user-images.githubusercontent.com/40673012/93746723-9401d800-fc30-11ea-81b6-328a7fc623ce.png">

- 그림 (a) : 앞에서 만든 힙으로 배열 A[1...6]이 힙을 이루고 있다
- 그림 (b) : 먼저 루트에 있는 3을 제거하고 배열의 맨 끝에 있는 7을 루트로 올린다. <br />
7을 옮긴 자리가 비어 있으므로 그 자리에 방금 제거한 3을 저장해둔다(남는 공간 활용). <br />
7이 루트로 올라서 두 자식과 비교해보니 힙성질이 깨졌다. <br />

- 그림 (c) : 두 자식 중 작은 값인 4를 7과 교환한다. 
- 그림 (d) : 루트에 있는 4를 제거하고 배열에 끝에 있는 9를 루트로 올린다. <br />
9가 올라가고 남은 자리에 방금 제거한 4를 저장해둔다. 
- 그림 (e)~(f) : 9가 루트로 오면서 힙성질이 깨졌으므로 수선을 한다. <br />

- 그림 (g) : 루트에 있는 6을 제거하고 배열의 끝에 있는 9를 올린다. <br />
9가 올라가고 남은 자리에 6을 저장해둔다. 
- 그림 (h) : 수선을 한다.<br />

- 그림 (i) :루트에 있는 7을 제거하고 배열의 끝에 있는 9를 올린다. <br />
9가 올라가고 남은 자리에 방금 제거한 7을 저장한다. 
- 그림 (j) : 수선을 한다. <br />

- 그림 (k) : 루트에 있는 8을 제거하고 배열의 끝에 있는 9를 올린다. <br />
9가 올라가고 남은 자리에는 방금 제거한 8을 저장해둔다. <br />
이 지점에서 A[...6]은 역순으로 정렬되어 있다.

### 알고리즘 4-8
```
heapSort(A,n){
    buildHeap(A,n);
    1) for i<-n downto 2{
    A[1] <-> A[i]; //원소 교환
    heapify(A, 1, i-1);
    }
}
```
- 알고리즘에서 heapify()는 알고리즘 4-7에서 사용한 heapify()와 동일하다

### 수행 시간
- 앞에서 언급한 바와 같이 buildHeap()은 Θ(n의 시간이 든다. <br />
- 1)의 for루프틑 n-1번 순환하고 각 순환에서 시간을 좌우하는 heapify()는 충분히 잡아서 <br />
O(logn)의 시간이면 된다. <br />
그러므로 힙 정렬의 총 수행 시간은 O(nlogn)이다. <br />

- heapify()의 시간을 충분히 잡았으므로 혹시 힙 정렬의 수행 시간이 O(nlogn)을 밑돌 수 있지 않을까 의심해볼 수도 있지만, <br />
다음 절에서 다루듯이 원소 간의 비교를 기반으로 하는 정렬은 아무리 잘해도 최악의 경우 <br />
Θ(nlogn)을 밑돌 수 없다.


## 3.4 수행 시간
