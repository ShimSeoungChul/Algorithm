# 03 레드 블랙 트리

- 이진 검색 트리는 저장과 검색에 평균 Θ(log n)이 소요되지만 운이 나빠 트리의 모양의 균형이 깨지면, <br />
Θ(n)에 근접한 시간이 소요될 수 있다. <br />
이를 방지하고 최악의 경우에도 이진 트리의 균형이 잘 맞도록 유지하기 위해 `균형잡힌 이진 검색 트리`가 고안 되었다.<br />
예) 레드 블랙 트리, AVL 트리 br />


## 레드 블랙 트리의 특성

- 레드 블랙 트리는 이진 검색 트리의 모든 노드에 레드 또는 블랙 색상을 칠한다. <br />
단, 다음 성질을 만족하도록 색칠을 해야한다(레드 블랙 특성). <br />
1. 루트는 블랙이다. <br />
2. 모든 리프(NIL)는 블랙이다.<br />
3. 노드가 레드이면 그 노드의 자식은 반드시 블랙이다. <br />
4. 루트 노드에서 임의의 리프 노드에 이르는 경로에서 만나는 블랙 노드의 수는 모두 같다. <br />

- 여기서 말하는 `리프 노드`는 일반적으로 말하는 리프 노드와 의미가 다르다. <br />
이진 검색 트리의 노드가 가진 두 개의 자식 포인터 중 `NIL`f인 것이 있다면 노드를 하나 만들어 그것을 리프 노드라 한다. <br />
이는 알고리즘에서 리프 노드가 개입될 때 특수 처리를 하지 않아도 되는 편리함이 있다. 

## 레드 블랙 트리의 그림 예

- 그림 6-10의 (b)는 이진 검색 트리를 레드 블랙 트리로 만든 예다. <br />
루트 노드는 블랙으로 색칠이 되어 `특성 1)`을 만족한다. <br />
임의의 노드에 자식이 없는 쪽은 모두 NIL 리프를 붙이고, 모든 NIL 리프는 블랙으로 색칠하여 `특성 2)`를 만족한다. <br />
임의의 노드가 레드이면 그 자식은 받드시 블랙이라는 `특성 3)`을 만족한다. <br />
루트에서 모든 리프 노드에 이르는 경로상에서 만나는 블랙 노드의 수는 항상 3개로 똑같아 `특성 4)`를 만족한다.<br />

- 실제로 구현할 때 `NIL 리프를 다루는 방식`은 모든 NIL 리프마다 하나씩 노드를 할당하는 것이 아니라, <br />
대신 `노드 하나를 할당`하여 이를 리프로 정하고 `모든 NIL 리프에 대한 포인터`가 이 노드를 가리키도록 한다. <br />
이를 통해 1.공간도 절약하고, 2. 경계조건을 다루기도 편리해진다(그림 6-10의 c).

<img width="445" alt="그림6-10" src="https://user-images.githubusercontent.com/40673012/94357637-93a48980-00d5-11eb-87bf-3adcb585916a.png">

- 레드 블랙 트리에서 `검색`은 내용을 건드리지 않으므로 이진 검색 트리와 동일하다
`삽입`과 `삭제`는 기본적으로 동일하지만 삽입, 삭제 후 레드 블랙 특성을 위반하는 경우가 발생할 수 있다. <br />
이때는 적절한 작업으로 레드 블랙 특성을 만족하도록 수정하자.

## 1 레드 블랙 트리에서 삽입 

- 이진 검색 트리의 삽입 알고리즘에 따라 삽입을 한 다음 새 노드의 색상을 레드로 칠한다. `이 노드를 x`라 하자.  <br />
새 노드는 항상 맨 아래쪽에 매달리므로 삽입 직후에 x의 아래쪽은 블랙 노드인 리프 2개만 있어 레드 블랙 특성에 문제가 생기지 않는다. <br />
`x의 위쪽`과 관련해서 문제가 생기는지만 확인하면 된다. <br />
`x의 부모 노드 p`가 블랙이면 삽입은 완료되므로, `p가 레드인 경우`만 해결하면 된다. <br />
p가 레드이면 레드 노드가 2개 연속 존재하므로 `특성 3`을 위배한다. <br />
그런데 삽입 전에는 레드 블랙 트리였으므로 특성 3에 따라 `p의 부모는 반드시 블랙`이다. 이를 `p²`라 하자.
마찬가지로 특성 3에 따라 `x의 형제 노드도 반드시 블랙`이다. 
x 주변에서 레드나 블랙 두 가지가 다 가능한 것은 `p의 형제 노드 s`뿐이다. s의 색상은 다음 두 가지 경우로 나눈다. 

### 1.1 case 1 : s가 레드
- 1) p와 s의 색상을 레드에서 블랙으로 바꾸고,  <br />
2) p²의 색상을 블랙에서 레드로 바꾼다. <br />
3-1) p²가 루트이면 p²의 색상을 다시 블랙으로 바꾸고 끝난다. <br />
3-2) p²가 루트가 아니면 p²의 부모 색상을 확인한다. <br />
4-1) p²의 부모 색상이 블랙이면 레드 블랙 특성이 모두 만족된다. <br />
4-2) p²의 부모 색상이 레드이면 `특성 3`이 위반되어 처음과 똑같은 문제가 발생한다. <br />
p²를 문제 발생 노드로 하여 `재귀적`으로 다시 시작한다.

### 1.2 case 2 : s가 블랙
#### case 2-1 : x가 p의 오른쪽 자식
- p를 중심으로 왼쪽으로 회전한다. 여전히 특성 3을 위반한다. case 2-2로 이동한다.

#### case 2-2 : x가 p의 왼쪽 자식
- 1) p²를 중심으로 오른쪽으로 회전하고 p와 p²의 색상을 맞바꾼다. <br />
2-1) Case 2를 만나면 Case2-2의 수선을 마지막으로 상황이 종료된다.  <br />
2-2) Case 1을 만나면 상황이 끝날 수도 있고, 똑같은 상황이 다른 노드에서 다시 시작될 수도 있다. <br />
이런 상황이 재귀적으로 반복되어 루트까지 올라갈 수도 있다.

<img width="405" alt="그림6-11" src="https://user-images.githubusercontent.com/40673012/94357639-98693d80-00d5-11eb-8067-01f748fee341.png">

## 2 레드 블랙 트리에서 삭제

- `이진 검색 트리에서 삭제 방법`에 따라 노드를 삭제한 후 색상을 맞추어준다. <br >

- 이진 검색 트리에서 `임의의 노드 d`를 삭제할 때 d의 자식이 둘이면,
d의 오른쪽 서브 트리에서 `최소 원소(노드 d의 직후 원소)를 가진 노드 m`의 키를 노드 d로 옮긴 다음 노드 m을 삭제한다. <br />
노드 d의 색상 변화 없이 키만 바꾸면 레드 블랙 특성에 영향을 미치지 않는다. <br />
`문제가 되는 것`은 노드 m을 삭제한 후 m 주변의 레드 블랙 특성의 위반 여부다.<br />

- 최소 원소 노드 m은 왼쪽 자식을 갖지 않아, 최대 한 개의 자식만 갖는다. <br />
따라서 두 개의 자식을 가진 노드의 삭제 작업은 자식이 없거나 한 개만을 가진 노드의 삭제 작업으로 귀결된다. <br />
때문에 레드 블랙 트리의 삭제 작업은 `자식이 없거나 한 개만을 가진 노드의 삭제에 국한해 설명`해도 무방하다.<br />

- `삭제하려고 하는 노드 m의 (최대 한 개의) 자식을 x`라고 하자. <br />
자식이 없으면 x는 NIL 노드가 된다.<br />

- m은 자기 부모 노드의 왼쪽 또는 오른쪽 자식일 수 있다. <br />
두 경우는 완전히 대칭적이므로 둘 중 하나만 설명해도 완결성이 떨어지지 않는다. <br />
여기서는 m이 자기 부모의 왼쪽 자식이라고 가정한다. <br />

### 간단한 경우
-  1. m이 레드이면 삭제 후 아무런 조치가 필요 없다. 레드 블랙 특성을 깨지 않는다(그림 6-12의 (a)). <br />
따라서 m이 블랙인 경우만 고려하면 된다.<br />

- 2. m이 블랙이더라도 x가 레드이면 삭제 후 x의 색상을 블랙으로 바꾸어버리면 레드 블랙 특성을 만족한다(그림 6-12 (b). <br />
그림에서 m의 부모 노드 색상은 표시하지 않았는데 이것은 어떤 색상이든 상관없다는 뜻이다.

### 까다로운 경우
- 3. m과 x의 색상이 모두 블랙일 때다. <br />
m과 x가 블랙인 상태에서 m이 삭제되면 x는 m의 부모 p의 자식이 되고, <br />
루트에서 x를 통과하는 경로의 블랙 노드 개수가 한 개 모자라서 레드 블랙 특성 4가 깨진다. <br />
그림 6-13의 (a)에서는 노드 m을 삭제하고 난 다음의 문제 상황을 보여준다. <br />
x 옆의 -1 표시는 루트에서 x를 지나는 경로에서 블랙 노드의 수가 하나 모자람을 의미한다. <br />
그림 6-13의 (b)에서는 x 주변의 노드들에 이름을 붙였다. `x의 부모를 p, x의 형제를 s, s의 두 자식을 l과 r`. <br />
이들 p, s, l, r의 색상 분포에 따라 여러 가지 경우로 나누어 처리한다. 

<img width="484" alt="그림6-13" src="https://user-images.githubusercontent.com/40673012/94357640-9901d400-00d5-11eb-9f69-bdbf9f525894.png">

- p의 색상에 따라 Case 1(레드)과 Case 2(블랙)로 나눈다. p가 레드이면 s는 반드시 블랙이다. <br />
l과 r은 모든 색상의 조합이 가능하다. <l의 색상, r의 색상> 조합에 따라 총 네 가지로 나눌 수 있다.  <br />
이 중 두 가지는 알고리즘에서 통합해서 처리하므로 다음과 같이 세 가지로 나눈다. *는 어떤 색생이든 상관없음을 의미. <br />

- Case 1: p가 레드(s는 반드시 블랙), <l의 색상, r의 색상>에 따라
     - case 1-1 <블랙, 블랙>
     - case 1-2 <레드, 레드> 또는 <블랙, 레드>    // <*,레드>로 표시
     - case 1-3 <레드, 블랙>
- Case 2: p가 블랙,  <s의 색상, l의 색상, r의 색상>에 따라
    - case 2-1 <블랙, 블랙, 블랙>
    - case 2-2 <블랙, 레드, 레드>또는 <블랙, 블랙, 레드>    // <블랙, *, 레드>로 표시
    - case 2-3 <블랙, 레드, 블랙> 
    - case 2-4 <레드, 블랙, 블랙>     // s가 레드이면 l과 r은 반드시 블랙<br />

- 아래 그림 6-14는 모든 가능한 경우의 수를 나열하고 있다. <br />
이 중 Case 1-2, 2-2는 p의 색상만 다르다. <br />
이들 경우 p의 색상이 처리 방법에 영향을 미치지 않으므로 통합한다. <br />
Case 1-3, 2-3 도 같은 이유로 통합한다. 최종적으로 알고리즘을 처리하는 경우의 수는 그림 6-15 처럼 다섯 가지다.

<img width="513" alt="그림6-14" src="https://user-images.githubusercontent.com/40673012/94357641-9a330100-00d5-11eb-81f9-67d53f84e6a3.png">



<img width="505" alt="그림6-15" src="https://user-images.githubusercontent.com/40673012/94357642-9acb9780-00d5-11eb-96c2-f37265f87438.png">

- Case 1-1

- Case *-2

- Case *-3

- Case 2-1

- Case 2-4

<img width="447" alt="그림6-16" src="https://user-images.githubusercontent.com/40673012/94357644-9b642e00-00d5-11eb-92e8-5fbc31c3ee78.png">


<img width="455" alt="그림6-16(2)" src="https://user-images.githubusercontent.com/40673012/94357646-9bfcc480-00d5-11eb-8b60-eee4de700e4e.png">

## 3 레드 블랙 트리의 작업 성능 분석
