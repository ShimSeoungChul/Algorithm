
- 적절한 자료구조와 알고리즘의 사용은 효율적인 데이터의 저장과 검색에서 매우 중요하다. <br />
데이터를 저장하는 효율적인 자료구조가 개발되기 전에는 데이터가 들어오는 대로 쌓아 저장은 쉽지만 검색은 번거로웠다. <br />
이진 검색 트리는 이보다 개선된 저장 방법으로 평균 Θ(logn) 시간에 저장과 검색을 할 수 있는 자료구조다.

# 01 레코드, 키의 정의 및 검색 트리

- 자료를 찾는 `색인(index) 역할`을 하는 자료구조의 예로 `이진 검색 트리`와 `해시 테이블`이있다. <br />

- 레코드는 개체에 대한 모든 정보를 포함하고 있다. <br />
ex) 사람의 레코드라면 주민번호, 이름, 집 주소, 집 전화번호, 직장 전화번호, 학력, 연소득 등의 정보가 포함될 수 있다. <br />
이 각각의 정보를 나타내는 부분을 `필드`라 한다. <br />

- 검색 트리에 레코드를 다 저장할 수 도 있으나 보통은 해당 레코드를 `대표할 수 있는 필드`만으로 검색 트리를 만든다. <br />
예를 들어 사람 레코드의 주민번호를 대표 필드로 삼아 검색 트리로 만들 수 있다. <br />
이렇게 다른 레코드와 중복되지 않으면서 레코드를 대표할 수 있는 필드를 `검색키(Search Key)` 또는 `키`라고 한다. <br />

- 키는 필드 하나 또는 복수 개의 필드로 구성할 수 있다. <br />
검색 색인을 만들기 위해서는 레코드 대신 키와 해당 레코드가 저장된 위치 정보만 있으면 된다.  <br />

- 검색 트리는 한 노드에서 최대 몇 개의 자식 노드로 분기를 할 수 있느냐에 따라 `이진 검색 트리`와 `다진 검색 트리`로 나눈다.  <br /> 
일반적으로 k진 검색 트리라 하면 자식을 최대 k개까지 가질 수 있는 검색 트리를 뜻한다. <br />

- 검색 트리는 저장되는 장소에 따라  `내부 검색 트리`와 `외부 검색 트리`로 나뉜다. <br />
내부 검색 트리는 검색 트리가 메인 메모리 내에, 외부 검색 트리는 외부(주로 디스크)에 존재한다. <br />
외부 검색 트리의 경우 디스크 접근 시간이 검색의 효율을 좌우한다. <br />

- 검색 트리는 검색키가 포함하는 필드의 수에 따라  `일차원 검색 트리`와  `다차원 검색 트리`로 나눈다. <br />
키를 구성하는 필드가 하나이면 일차원 검색 트리, 두 개 이상이면 다차원 검색 트리다. <br />
일차원 검색 트리 예: 이진 검색 트리, 다진 검색 트리, B-트리 AVL-트리, 레드 블랙 트리 등 <br />
다차원 검색 트리 예: KD-트리, KDB-트리, R-트리 등


# 02 이진 검색 트리

## 이진 검색 트리의 특징 
1. 이진 검색 트리의 각 노드는 키 값을 하나씩 갖는다. 각 노드의 키 값은 모두 달라야 한다.  <br />
2. 최상위 레벨에 루트 노드가 있고, 각 노드는 최대 두 개의 자식 노드를 갖는다. <br />
3. 임의의 노드의 키 값은 자신의 왼쪽에 있는 모든 노드의 키 값보다 크고, 오른쪽에 있는 모든 노드의 키 값보다 작다.

## 이진 검색 트리와 서브 트리의 예
- 서브 트리는 검색 트리 내에 존재하는 부분적인 트리이다.

<img width="473" alt="스크린샷 2020-09-26 오후 3 51 28" src="https://user-images.githubusercontent.com/40673012/94332441-6510ab00-0010-11eb-947d-011835d22db5.png">


## 1 이진 검색 트리에서 검색
- 이진 검색 트리에서 키가 x인 노드를 검색할때, <br />
트리에 키가 x인 노드가 존재하면 해당 노드를 리턴하고, 존재하지 않으면 NIL을 리턴한다.

### 알고리즘 6-1 이진 검색 트리에서 검색
```
// t: 트리의 루트 노드
// x: 검색하고자 하는 키
treeSearch(t, x){
    1) if(t = NIL or key[t] = x) then return t;
    if(x<key[t])
    2) then return treeSearch(left[t],x);
    3) else return treeSearch(right[t],x);
}
```

- 2) 루트 노드 t의 키 값과 x를 비교해 x가 더 작으면 t의 왼쪽 서브 트리로 가서 x를 찾는다.
- 3) x가 더 크면 t의 오른쪽 서브 트리로 가서 x를 찾는다.
- 1) 루트 노드의 키 값이 x와 일치하면 루트 노드가 답이라고 알린다. <br />
t가 NIL이면 검색이 실패했음을 알린다. <br />
검색이 성공하든 실패하든 반드시 1)을 통해서 끝난다. 

### 그림을 통한 이해
- 아래 그림은 이진 트리 검색에서 t의 주변 상황을 `관계적 관점`에서 보인 것이다. <br />
루트 노드 t에서 왼쪽 자식 lef[t]로 분기를 하는 것은 2)의 treeSearch(left[t], x)이다.  <br />
이것은 left[t]가 새로운 루트가 되었을 뿐 앞의 treeSearch(t,x)와 똑같은 작업이다.<br />
즉, 루트 노드와 x의 대소를 비교하는 수고를 하고 나면 자신과 성격은 똑같으면서 크기만 더 작은 문제를 만난다. <br />


<img width="291" alt="이진 트리 검색에서 재귀적 관점" src="https://user-images.githubusercontent.com/40673012/94335066-c423ef00-0013-11eb-92f5-d6f2aa7aa3bd.png">


- 아래 그림은 이진 트리에서 검색이 성공하는 경우와 실패하는 경우를 간단하게 그린 것이다. <br />

- (a)는 `성공적인 검색`을 보여주는 예로 treeSearch(*,x)를 재귀적으로 수행하다 x를 가진 노드(r)를 만나면 해당 노드를 리턴한다. <br />
여러 번의 자기호출 끝에 treeSearch(r,x)가 호출되는 순간 r의 키 값과 x가 일치하면 [알고리즘 6-1]의 1)에서 r을 리턴하고 끝난다. <br />

- (b)는 `실패하는 검색`을 보여주는 예로, 루트 노드에서 시작해 리프 노드 e까지 온 경우다. <br />
x와 e의 키 값을 비교해 x의 대소 여부에 따라 왼쪽 또는 오른쪽으로 분기를 시도하는데 <br />
e는 자식 노드가 없으므로 e에서 분기한다는 것은 NIL로 분기를 하는 것이다. <br />
즉, treeSearch(left[e], x)는 treeSearch(NIL, x)와 같다. <br />
treeSearch()가 호출되자마자 루트 노드가 NIL이므로 NIL을 리턴하고 끝난다.


<img width="302" alt="성공적인 검색과 실패하는 검색" src="https://user-images.githubusercontent.com/40673012/94335069-c7b77600-0013-11eb-8696-98a5caa87b08.png">



## 2 이진 검색 트리에서 삽입
- 원소 x를 이진 검색 트리에 삽입하려면 우선 이진 검색 트리에 x를 키 값으로 가진 노드가 없어야 한다. <br />
즉, 루트 노드에서 x에 대한 검색(검색과 똑같은 과정)을 수행해 임의의 리프 노드에 이르러 <br />
더 이상 내려갈 곳이 없음이 확인되면 x를 그 리프 노드의 자식으로 매단다.  <br />

- 이진 검색 트리의 모양은 원소들이 삽입되는 순서에 따라 결정된다.

- 다음은  이진 검색 트리가 만들어지는 과정을 보여준다.

<img width="454" alt="삽입과정" src="https://user-images.githubusercontent.com/40673012/94336052-0270dc80-001b-11eb-937f-0ab33c4c7c23.png">


- 그림 (a): 아무것도 없는 상태에서 30이 삽입되면 30 하나로 이루어진 트리가 만들어진다.
- 그림 (b): 20이 입력되면 30보다 작으므로 30의 왼쪽에 매단다.
- 그림 (c): 25가 입력되면 30보다 작으므로 30의 왼쪽으로 간다. 20보다는 크므로 20의 오른쪽에 매단다.
- 그림 (d): 40이 입력되면 30보다 크므로 30의 오른쪽에 매단다.
- 그림 (e): 10이 입력되면 30보다 작으므로 왼쪽으로, 20보다도 작으므로 20의 왼쪽에 매단다.
- 그림 (f): 35가 입력되면 30보다 크므로 오른쪽으로, 40보다는 작으므로 40의 왼쪽에 매단다. 

### 알고리즘 6-2 이진 검색 트리에서 삽입 스케치

- 다음은 삽입의 개요를 기술한 것이다. <br />
1)은 검색이 실패했음을 알게 되는 부분이다. <br />
2)에서 검색이 성공하는 경우도 있지만 삽입에서는 같은 키 값이 트리 내에 없어야 삽입할 수 있으므로 <br />
검색이 실패하는 경우밖에 없다. <br />
2)와 3)은 검색어와 완전히 동일하다.

```
//t: 트리의 루트 노드
//x: 삽입하고자 하는 키
sketchInsert(t,x){
    1) if(t=NIL) then x를 키로 하는 노드를 t의 부모 밑에 매달고 return;
    if(x < key[t])
        2) then sketchInsert(left[t], x);
        3) else sketchInsert(right[t],x);
}
```

### 알고리즘 6-3 이진 검색 트리에서 삽입
- 아래는 알고리즘 6-2를 더 구체적으로 묘사한 것으로 부모 노드에서 포인터 정보 갱신을 재귀 함수의 리턴 값을 이용해 <br />
처리하는 다소 고급스런 로직을 포함한다(1,2).

```
//t: 트리의 루트 노드
//x: 삽입하고자 하는 키
treeInsert(t, x){
    if(t=NIL) then {
        key[r]<-x;  left[r] <-NIL; right[r] <- NIL; //r: 새 노드
        return r;  
    }
    if(x<key[t])
        1) then {left[t]<-treeInsert(left[t],x); return t;}
        2) else {right[t]<-treeInsert(right[t],x); return t;}
}
```

### 6-4 이진 검색 트리에서 삽입 (비재귀 버전)
- 아래는 알고리즘 6-3과 다르게 재귀를 사용하지 않는다. <br />
재귀를 사용할 때보다 코드가 상당히 지저분하다. 여기서 재귀적 사고의 유용성을 볼 수 있다.

```
//t: 트리의 루트 노드
//x: 삽입하고자 하는 키
treeInsert(t,x){
  key[r]<-x;  left[r] <-NIL; right[r] <- NIL; //r: 새 노드
  if(t=NIL) then root<-r;
  else{
    p<-NIL; tmp<-t;
    while(tmp != NIL){
        p<-tmp;
        if(x<key[tmp]) then tmp <-left[tmp];
                        else tmp <- right[tmp];
    }
    if(x<key[p]) then left[p]<-r;
                 else right[p]<-r;
  }
}
```

### 그림을 통한 이해
- 위의 그림 6-5의 이진 검색 트리는 좌우의 균형이 잘 잡힌 검색 트리다. <br />
검색 트리의 효율은 `검색 트리의 깊이`와 밀접한 상관이 있어, 이렇게 `균형`이 잘 맞으면 검색의 효율이 높다.<br />
하지만 트리의 균형이 잘 맞지 않은 경우도 발생한다.<br />

- 아래 그림에서는 트리의 모양이 오른쪽으로 치우쳐 있다. <br />
이 트리에서 45를 검색할 루트 노드 부타 경우 트리의 모든  원소와 비교해야하기 때문에 검색 효율성이 나쁘다.

<img width="292" alt="스크린샷 2020-09-27 오전 10 23 47" src="https://user-images.githubusercontent.com/40673012/94353388-94c0c100-00ab-11eb-83cc-ceb0174f1f8e.png" style="max-width:100%;">


- n개의 원소로 이진 검색 트리를 만들 때, <br />
이진 검색 트리가 가장 `이상적으로 균형`이 잡히면 `최악의 경우`에도 검색 시간은  Θ(logn)이다.  <br />
`가장 나쁘게 기울면` `평균 검색 시간`이 Θ(logn)이 된다. <br />
가능한 모든 삽입 순서에 따른 이진 검색 트리를 모두 고려하면 `평균 검색 시간`은 Θ(logn)이다. <br />
`삽입`은 실패하는 검색 후 상 수 시간의 후처리를 하므로 점근적 수행 시간은 `검색과 동일`하다. 

## 3 이진 검색 트리에서 삭제
- 삭제의 경우 삭제할  노드 r이 정해지면 다음 `세 가지` 경우에 따라 각각 다르게 처리한다.  <br />
Case 1 : r이 리프 노드인 경우 <br />
Case 2 : r의 자식 노드가 하나인 경우 <br />
Case 3 : r의 자식 노드가 두 개인 경우

### 알고리즘 6-5 이진 검색 트리에서 삭제 스케치
```
//t: 트리의 루트 노드
//r: 삭제하고자 하는 노드
sketchDelete(t,r){
    if (r이 리프 노드) then 그냥 r을 버린다.   //Case 1
    else if(r의 자식이 하나만 있음) then r의 부모가 r의 자식을 직접 가리키도록 한다. //Case 2
    else{   //Case 3
        r의 오른쪽 서브 트리의 최소 원소 노드 s를 삭제하고, s를 r 자리에 놓는다.
    }
}
```

- `Case1`에서 r은 리프 노드이므로 자식이 없어 r이 삭제되어도 r의 아래쪽에 영향을 미치지 않는다. <br />
단지 r의 부모 노드에서 r을 가리키고 있던 포인터를 NIL로만 바꿔주면 된다. <br />

- `Case2`에서는 r을 제거하면 r과 자식 노드의 연결이 끊어진다. <br />
r의 부모 노드에서 r을 가리키고 있던 포인터를 r의 자식을 가리키도록 바꾸면 된다.

<img width="495" alt="Case1과2" src="https://user-images.githubusercontent.com/40673012/94354093-a9548780-00b2-11eb-897b-2e103388dfa2.png">

- `Case3` 은 r이 자식들과 연결이 끊어지는 것은 Case2와 같다. <br />
하지만 r의 자식은 둘이므로 r 자리에 옮겨놓아도 `이진 검색 트리의 성질을 깨지 않는 원소`를 찾아야한다. <br />
이런 원소는 왼쪽 서브 트리의 원소들보다 크고 오른쪽 서브 트리의 원소들보다 작아햐하므로, <br />
`r의 왼쪽 서브 트리에서 가장큰 원소` 또는 `r의 오른쪽 서브 트리에서 가장 작은 원소` 둘 중 하나를 택해(여기서는 직후 원소를 택하기로 한다) 키를 r자리로 옮긴다. <br />
그 후 `직후 원소`가 들어 있던 노드를 삭제하고, 직후 원소의 부모가 직후 원소를 가리키던 포인터를 직후 원소의 자식을 가리키도록 바꾼다. <br />
다행히 직후 원소는 절대 왼쪽 자식을 가질 수 없다(r의 오른쪽 자식에서 시작하여 왼쪽으로 분기할 수 없으면 그 것이 직후 원소다).
<br /> 그러므로 직후 원소의 삭제는 Case1, 2에 속하게 되어 비교적 간단한 삭제 작업이 된다.

<img width="462" alt="Case3" src="https://user-images.githubusercontent.com/40673012/94354099-ae193b80-00b2-11eb-8a84-6b0ed2248d89.png">

### 알고리즘 6-6 이진 검색 트리에서 삭제
```
//t: 트리의 루트 노드
//r: 삭제하고자 하는 노드, p: r의 부모 노드
treeDelete(t,r,p){
    //r이 루트 노드인 경우
    if(r=t) then root <- deleteNode(t);
    //r이 루트 노드가 아닌 경우
    else if(r=left[p])
        then left[p] <- deleteNode(r);  //r이 p의 왼쪽 자식
        else right[p] <- deleteNode(r); //r이 p의 오른쪽 자식
}

deleteNode(r){
    if(left[r] = right[r] = NIL) then return NIL;   //Case 1
    else if(left[r] = NIL and right[r] != NIL) then return right[r];    //Case 2-1
    else if(left[r] != NIL and right[r] = NIL) then return left[r]; //Case 2-1
    else{           //Case 3
        s <- right[r];
        while(left[s] != NIL){
            parent <- s; s<- left[s];
        }
        
        key[r] <- key[s];
        if(s = right[r]) then right[r] <- right[s];
        else left[parent] <- right[s];
        
        return r;
    }
}
```

### 삭제 작업의 수행 시간
- Case 1과 Case 2는 상 수 시간이 든다.
- Case 3은 노드 r의 직후 원소를 찾는데 최악의 경우 트리의 높이에 비례하는 시간이 든다.  <br />
직후 원소를 찾은 다음 삭제하는 것은 Case 1 또는 Case 2에 해당되므로 상수 시간이 든다. <br />
따라서 삭제 작업을 위한 최악의 시간은 트리에 높이에 따라 O(logn)과 O(n)사이에서 결정된다.
